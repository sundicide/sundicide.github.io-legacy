<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../../img/favicon.ico">
        <title>Week3-3: Conditional Implicit Definitions - sundicide</title>
        <link href="../../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../../../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../../..">sundicide</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../../../.." class="nav-link">Welcome to MkDocs</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Scala <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../" class="dropdown-item">Welcome</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Coursera</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../" class="dropdown-item">Index</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Fpd in scala</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../" class="dropdown-item">Index</a>
</li>
            
<li>
    <a href="../week1_1-RecapFunctionsAndPatternMatching/" class="dropdown-item">Week1-1: Recap: Functions and Pattern Matching</a>
</li>
            
<li>
    <a href="../week1_2-RecapCollections/" class="dropdown-item">Week1-2: Recap: Collections</a>
</li>
            
<li>
    <a href="../week3_1-typedirectedprogramming/" class="dropdown-item">Week3-1: Type-Directed Programming</a>
</li>
            
<li>
    <a href="../week3_2-typeclasses/" class="dropdown-item">Week3-2: Type Classes</a>
</li>
            
<li>
    <a href="./" class="dropdown-item active">Week3-3: Conditional Implicit Definitions</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Fpp in scala</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../fpp-in-scala/week1/" class="dropdown-item">Week1</a>
</li>
            
<li>
    <a href="../../fpp-in-scala/week1_1-ProgrammingParadigms/" class="dropdown-item">Lecture 1.1 - Programming Paradigms</a>
</li>
            
<li>
    <a href="../../fpp-in-scala/week2/" class="dropdown-item">Higher order functions</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../week3_2-typeclasses/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../../fpp-in-scala/week1/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#week3-3-conditional-implicit-definitions" class="nav-link">Week3-3: Conditional Implicit Definitions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#recursive-implicit-definitions" class="nav-link">Recursive Implicit Definitions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#example-sort-by-multiple-criteria" class="nav-link">Example: Sort by Multiple Criteria</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#summary" class="nav-link">Summary</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="week3-3-conditional-implicit-definitions">Week3-3: Conditional Implicit Definitions</h1>
<p>In this lesson, we will see that implicit definitions can themselves take implicit parameters.</p>
<p>Let’s start with an example. Consider how we order two String values: is "abc" lexicographically before "abd"?</p>
<p>To answer this question, we need to compare all the characters of the String values, element-wise:</p>
<ul>
<li>is a before a? No.</li>
<li>is b before b? No.</li>
<li>is c before d? Yes!</li>
<li>We conclude that "abc" is before "abd".</li>
</ul>
<p>So, we compare two sequences of characters with an algorithm that compares the characters of the sequences element-wise. Said otherwise, we can define an ordering relation for sequence of characters based on the ordering relation for characters.</p>
<p>Can we generalize this process to sequences of any element type A for which there is an implicit Ordering[A] instance?</p>
<p>The signature of such an Ordering[List[A]] definition takes an implicit parameter of type Ordering[A]:</p>
<pre><code class="scala">implicit def orderingList[A](implicit ord: Ordering[A]): Ordering[List[A]]
</code></pre>

<p>For reference, a complete implementation is shown below. You can see that at some point in the algorithm we call the operation compare of the ord parameter:</p>
<pre><code class="scala">implicit def orderingList[A](implicit ord: Ordering[A]): Ordering[List[A]] =
  new Ordering[List[A]] {
    def compare(xs: List[A], ys: List[A]) =
      (xs, ys) match {
        case (x :: xsTail, y :: ysTail) =&gt;
          val c = ord.compare(x, y)
          if (c != 0) c else compare(xsTail, ysTail)
        case (Nil, Nil) =&gt; 0
        case (_, Nil)   =&gt; 1
        case (Nil, _)   =&gt; -1
      }
  }
</code></pre>

<p>With this definition, we can sort a list of list of numbers, for example:</p>
<pre><code class="scala">scala&gt; val xss = List(List(1, 2, 3), List(1), List(1, 1, 3))
res0: List[List[Int]] = List(List(1, 2, 3), List(1), List(1, 1, 3))

scala&gt; sort(xss)
res1: List[List[Int]] = List(List(1), List(1, 1, 3), List(1, 2, 3))
</code></pre>

<p>But let’s take a step back. We haven’t defined an instance of Ordering[List[Int]] and yet we have been able to sort a list of List[Int] elements! How did the compiler manage to provide such an instance to us?</p>
<p>This happened in several steps.</p>
<p>First, we called sort(xss). The compiler fixed the type parameter A of the method to List[Int], based on the type of the argument xss, as if we had written:</p>
<pre><code class="scala">sort[List[Int]](xss)
</code></pre>

<p>Then, the compiler searched for an implicit definition of type Ordering[List[Int]]. It found that our orderingList definition could be a match under the condition that it could also find an implicit definition of type Ordering[Int], which it eventually found. Finally, the compiler inserted the following arguments for us:</p>
<pre><code class="scala">sort[List[Int]](xss)(orderingList(Ordering.Int))
</code></pre>

<p>In this case, the compiler combined two implicit definitions (orderingList and Ordering.Int) before terminating. In general, though, an arbitrary number of implicit definitions can be combined until the search hits a “terminal” definition.</p>
<p>Consider for instance these four implicit definitions:</p>
<pre><code class="scala">implicit def a: A = ...
implicit def aToB(implicit a: A): B = ...
implicit def bToC(implicit b: B): C = ...
implicit def cToD(implicit c: C): D = ...
</code></pre>

<p>We can then ask the compiler to summon a value of type D:</p>
<pre><code class="scala">implicitly[D]
</code></pre>

<p>The compiler finds that there is a candidate definition, cToD, that can provide such a D value, under the condition that it can also find an implicit definition of type C. Again, it finds that there is a candidate definition, bToC, that can provide such a C value, under the condition that it can also find an implicit definition of type B. Once again, it finds that there is candidate definition, aToB, that can provide such a B value, under the condition that it can also find an implicit value of type A. Finally, it finds a candidate definition for type A and the algorithm terminates!</p>
<p>At the beginning of this lesson, we showed that by using implicit parameters the compiler could infer simple arguments for us. We have now reached a point where we can appreciate that the compiler can infer more complex arguments (by inferring arguments of arguments!).</p>
<p>It not only significantly reduces code verbosity, it also alleviates developers from implementing parts of their programs, which are summoned by the compiler based on their type (hence the name “type-directed programming”). In practice, complex fragments of programs such as serializers and deserializers of data types can be summoned by the compiler.</p>
<h2 id="recursive-implicit-definitions">Recursive Implicit Definitions</h2>
<p>What happens if we write an implicit definition that depends on itself?</p>
<pre><code class="scala">trait X

implicit def loop(implicit x: X): X = x

implicitly[X]
</code></pre>

<p>The compiler detects that it keeps searching for an implicit definition of the same type and returns an error:</p>
<pre><code>error: diverging implicit expansion for type X
starting with method loop
</code></pre>

<p>Note: it is possible to write recursive implicit definitions by making sure that the search always terminates, but this is out of the scope of this lesson.</p>
<h2 id="example-sort-by-multiple-criteria">Example: Sort by Multiple Criteria</h2>
<p>Consider a situation where we want to compare several movies. Each movie has a title, a rating (in number of “stars”), and a duration (in minutes):</p>
<pre><code class="scala">case class Movie(title: String, rating: Int, duration: Int)

val movies = Seq(
  Movie(&quot;Interstellar&quot;, 9, 169),
  Movie(&quot;Inglourious Basterds&quot;, 8, 140),
  Movie(&quot;Fight Club&quot;, 9, 139),
  Movie(&quot;Zodiac&quot;, 8, 157)
)
</code></pre>

<p>We want to sort movies by rating first, and then by duration.</p>
<p>To achieve this, a first step is to change our sort function to take as parameter the sort criteria in addition to the elements to sort:</p>
<pre><code class="scala">def sort[A, B](elements: Seq[A])(critera: A =&gt; B)(implicit
  ord: Ordering[B]
): Seq[A] = ...
</code></pre>

<p>The sort algorithm remains the same except that instead of comparing the elements together, we compare the criteria applied to each element.</p>
<p>With this function, here is how we can sort movies by title:</p>
<pre><code class="scala">sort(movies)(_.title)
</code></pre>

<p>And here is how we can sort them by rating:</p>
<pre><code class="scala">sort(movies)(_.rating)
</code></pre>

<p>Each time the sort function is called, its ordering parameter is inferred by the compiler based on the type of the criteria (String and then Int, in the above examples).</p>
<p>However, our initial problem was to sort the movies by multiple criteria. We would like to sort first by rating and then by duration:</p>
<pre><code class="scala">sort(movies)(movie =&gt; (movie.rating, movie.duration))
</code></pre>

<p>The type of the criteria is now a tuple type (Int, Int). Unfortunately, the compiler is unable to infer the corresponding ordering parameter. We need to define how simple orderings can be combined together to get an ordering for multiple criteria.</p>
<p>We do so by defining the following implicit ordering:</p>
<pre><code class="scala">implicit def orderingPair[A, B](implicit
  orderingA: Ordering[A],
  orderingB: Ordering[B]
): Ordering[(A, B)] = ...
</code></pre>

<p>This definition provides an ordering for pairs of type (A, B) given orderings for types A and B.</p>
<p>The complete implementation is the following:</p>
<pre><code class="scala">implicit def orderingPair[A, B](implicit
  orderingA: Ordering[A],
  orderingB: Ordering[B]
): Ordering[(A, B)] =
  new Ordering[(A, B)] {
    def compare(pair1: (A, B), pair2: (A, B)): Int = {
      val firstCriteria = orderingA.compare(pair1._1, pair2._1)
      if (firstCriteria != 0) firstCriteria
      else orderingB.compare(pair1._2, pair2._2)
    }
  }
</code></pre>

<p>We first compare the two values according to the first criteria, and if they are equal we compare them according to the second criteria.</p>
<p>With this definition, the compiler is now able to infer the ordering for the following call:</p>
<pre><code class="scala">sort(movies)(movie =&gt; (movie.rating, movie.duration))
</code></pre>

<p>Here is the same call where the inferred parameter is explicitly written:</p>
<pre><code class="scala">sort(movies)(movie =&gt; (movie.rating, movie.duration))(
  orderingPair(Ordering.Int, Ordering.Int)
)
</code></pre>

<p>Note that in the standard library the sort function that we have defined here is already available as a method sortBy on collections.</p>
<h2 id="summary">Summary</h2>
<p>In this lesson, we have seen that:</p>
<ul>
<li>implicit definitions can also take implicit parameters,
 an arbitrary number of implicit definitions can be chained until a terminal definition is reached.</li>
</ul></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../../js/base.js" defer></script>
        <script src="../../../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
