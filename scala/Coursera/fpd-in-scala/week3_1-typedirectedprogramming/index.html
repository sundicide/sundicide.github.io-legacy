<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../../img/favicon.ico">
        <title>Week3-1: Type-Directed Programming - sundicide</title>
        <link href="../../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../../../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../../..">sundicide</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../../../.." class="nav-link">Welcome to MkDocs</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Scala <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../" class="dropdown-item">Welcome</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Coursera</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../" class="dropdown-item">Index</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Fpd in scala</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../" class="dropdown-item">Index</a>
</li>
            
<li>
    <a href="../week1_1-RecapFunctionsAndPatternMatching/" class="dropdown-item">Week1-1: Recap: Functions and Pattern Matching</a>
</li>
            
<li>
    <a href="../week1_2-RecapCollections/" class="dropdown-item">Week1-2: Recap: Collections</a>
</li>
            
<li>
    <a href="./" class="dropdown-item active">Week3-1: Type-Directed Programming</a>
</li>
            
<li>
    <a href="../week3_2-typeclasses/" class="dropdown-item">Week3-2: Type Classes</a>
</li>
            
<li>
    <a href="../week3_3-ConditionalImplicitDefinitions/" class="dropdown-item">Week3-3: Conditional Implicit Definitions</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Fpp in scala</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../fpp-in-scala/week1/" class="dropdown-item">Week1</a>
</li>
            
<li>
    <a href="../../fpp-in-scala/week1_1-ProgrammingParadigms/" class="dropdown-item">Lecture 1.1 - Programming Paradigms</a>
</li>
            
<li>
    <a href="../../fpp-in-scala/week2/" class="dropdown-item">Higher order functions</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../week1_2-RecapCollections/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../week3_2-typeclasses/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#week3-1-type-directed-programming" class="nav-link">Week3-1: Type-Directed Programming</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#motivating-example" class="nav-link">Motivating Example</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#refactoring-with-ordering" class="nav-link">Refactoring With Ordering</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#reducing-boilerplate" class="nav-link">Reducing Boilerplate</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#implicit-parameters" class="nav-link">Implicit Parameters</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#candidates-for-implicit-parameters" class="nav-link">Candidates for Implicit Parameters</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#context-bounds" class="nav-link">Context Bounds</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#implicit-query" class="nav-link">Implicit Query</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#summary" class="nav-link">Summary</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="week3-1-type-directed-programming">Week3-1: Type-Directed Programming</h1>
<p>지금까지 봤듯이 compiler는 values로 부터 types을 유추할 수 있다.</p>
<pre><code class="scala">val x = 12
</code></pre>

<p>compiler는 x를 Int로 유추한다. 왜냐하면 값이 12이므로
아래와 같이 복잡한 표현에서도 이는 적용된다.</p>
<pre><code class="scala">val y = x + 3
</code></pre>

<p>compiler는 y 또한 Int로 유추한다.</p>
<p><br />
이번에는 반대로 compiler가 types로 부터 values를 유추하는 과정을 볼 것이다.
왜 이것이 유용하냐? 확실한 하나는 compiler가 value를 찾아서 줄 수 있기 때문이다.</p>
<p>이번 레슨의 나머지는 이런 메카니즘의 motivation을 소개하고 다음 번 레슨은 how to use it을 설명할 것이다.</p>
<h2 id="motivating-example">Motivating Example</h2>
<p>parameter로 List[Int]를 받아서 정렬한 결과를 List[Int]로 리턴하는 함수를 생각해보자.</p>
<pre><code class="scala">def sort(xs: List[Int]): List[Int] = {
  ...
  ... if (x &lt; y) ...
  ...
}
</code></pre>

<p>상세 코드는 여기에서 필요가 없기에 생략했다. 위 코드는 Int에 대해서만 적용 가능하므로 general하게 모든 타입에 대해서도 동작하게 하고 싶다.
이에 대한 straightforward approach는 polymorphic type을 사용하는 것이다.</p>
<pre><code class="scala">def sort[A](xs: List[A]): List[A] = ...
</code></pre>

<p>하지만 이것만으로는 부족하다. 왜냐하면 각 type별로 compare를 다르게 해야 하기 때문이다.
그래서 이번엔 각 compare 함수를 parameter로 받도록 해보자.</p>
<pre><code class="scala">def sort[A](xs: List[A])(lessThan: (A, A) =&gt; Boolean): List[A] = {
  ...
  ... if (lessThan(x, y)) ...
  ...
}
</code></pre>

<p>그렇게 되면 아래와 같이 가능하다'</p>
<pre><code class="scala">val xs = List(-5, 6, 3, 2, 7)

val strings = List(&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;pineapple&quot;)

sort(xs)((x, y) =&gt; x &lt; y)

sort(strings)((s1, s2) =&gt; s1.compareTo(s2) &lt; 0)
</code></pre>

<h2 id="refactoring-with-ordering">Refactoring With Ordering</h2>
<p>scala는 standard library 에서 comparing 하는 함수를 기본으로 제공한다.</p>
<pre><code class="scala">package scala.math

trait Ordering[A] {
  def compare(a1: A, a2: A): Int
  def lt(a1: A, a2: A): Boolean = compare(a1, a2) &lt;= 0
  ...
}
</code></pre>

<p>compare 함수는 2개의 parameter를 받아서 첫 번째 값이 클 경우 양수, 작을 경우 음수, 동일한 경우 0을 리턴한다.</p>
<p>이를 사용하면 아래와 같이 변경 가능하다.</p>
<pre><code class="scala">def sort[A](xs: List[A])(ord: Ordering[A]): List[A] = {
  ...
  ... if (ord.lt(x, y)) ...
  ...
}
</code></pre>

<pre><code class="scala">import scala.math.Ordering

sort(xs)(Ordering.Int)
sort(strings)(Ordering.String)
</code></pre>

<p>여기에서 사용 중인 Int와 String은 <code>types</code>이 아니고 <code>values</code>임을 알아야 한다.
scala에서는 types과 values에 동일한 symbol을 사용하는 것이 가능하다.</p>
<pre><code class="scala">object Ordering {
  val Int = new Ordering[Int] {
    def compare(x: Int, y: Int) = if (x &gt; y) 1 else if (x &lt; y) -1 else 0
  }
}
</code></pre>

<h2 id="reducing-boilerplate">Reducing Boilerplate</h2>
<p>지금까지 정의한 것을 따르면 잘 동작한다.
하지만 모든 경우에 대해 boilerplate가 존재하게 된다. Int를 비교할 때마다 <code>Ordering.Int</code>를 반복적으로 사용해야 한다.</p>
<pre><code class="scala">sort(xs)(Ordering.Int)
sort(ys)(Ordering.Int)
sort(strings)(Ordering.String)
</code></pre>

<h2 id="implicit-parameters">Implicit Parameters</h2>
<p><code>implicit</code>을 명시함으로서 compiler가 argument <code>ord</code>를 support를 하게 할 수 있다.</p>
<pre><code class="scala">def sort[A](xs: List[A])(implicit ord: Ordering[A]): List[A] = ...
</code></pre>

<pre><code class="scala">sort(xs)
sort(ys)
sort(strings)
</code></pre>

<p>위와 같이 하면 컴파일러가 value에 맞춰 type을 결정한다.</p>
<p>컴파일러가 수행하는 과정을 자세히 살펴보자.</p>
<pre><code class="scala">sort(xs)
</code></pre>

<p>xs 가 List[Int] 타입이므로 컴파일러는 위의 코드를 아래와 같이 변환한다.</p>
<pre><code class="scala">sort[Int](xs)
</code></pre>

<p>그리고 컴파일러는 candidate definition중 Ordering[Int] 타입에 맞는 것을 찾는다. 위의 케이스에서는 Ordering.Int와 only matching되고 컴파일러는 method sort로 이를 전달한다.</p>
<pre><code class="scala">sort[Int](xs)(Ordering.Int)
</code></pre>

<p>candidate values가 어떻게 정의도어있는 지를 살펴 보기 전에 implicit 키워드에 대해 자세히 알아보자.</p>
<ol>
<li>method는 오직 하나의 implicit parameter list를 가질 수 있으며 이는 마지막 paramter가 되야 한다.</li>
<li>At call site, the arguments of the given clause are usually left out, although it is possible to explicitly pass them:</li>
</ol>
<pre><code class="scala">// Argument inferred by the compiler
sort(xs)

// Explicit argument
sort(xs)(Ordering.Int.reverse)
</code></pre>

<h2 id="candidates-for-implicit-parameters">Candidates for Implicit Parameters</h2>
<p>컴파일러가 type T에 대해 어떤 candidate definition를 찾을까?
컴파일러는 아래 definition을 찾는다.</p>
<ul>
<li>have type T,</li>
<li>are marked implicit,</li>
<li>are visible at the point of the function call, or are defined in a companion object associated with T.</li>
</ul>
<p>most specific한 정의를 찾게 되면 그것을 사용하고 없다면 error를 report한다.</p>
<h3 id="implicit-definition">implicit Definition</h3>
<p>implicit definition이란 implicit 키워드와 함께 정의된 것을 말한다.</p>
<pre><code class="scala">object Ordering {
  implicit val Int: Ordering[Int] = ...
}
</code></pre>

<p>위의 코드는 Int라는 이름을 가진 Ordering[Int] 타입의 implicit value를 정의한 것이다.</p>
<p>Any val, lazy val, def, or object definition can be marked implicit.</p>
<p>마지막으로 implicit definitions는 type parameters와 implicit parameters를 가질 수 있다.</p>
<pre><code class="scala">implicit def orderingPair[A, B](implicit
  orderingA: Ordering[A],
  orderingB: Ordering[B]
): Ordering[(A, B)] = ...
</code></pre>

<h3 id="implicit-search-scope">Implicit Search Scope</h3>
<p>type T의 implicit value를 찾기 위해 첫 번째로 visible(inherited, imported, or defined in an enclosing scope)한 모든 implicit definitions를 찾는다.</p>
<p>만약 컴파일러가 lexcial scope에서 implicit instance와 매칭되는 type T를 찾지 못하면, T와 관련된 companion objects에서 이어서 찾는다. (companion objects와 types는 other types와 연관있다.)</p>
<p>A companion object is an object that has the same name as a type. 예로 object scala.math.Ordering is the companion of the type scala.math.Ordering.</p>
<p>The types associated with a type T are:</p>
<ul>
<li>if T has parent types T₁ with T₂ ... with Tₙ, the union of the parts of T₁, ... Tₙ as well as T itself,</li>
<li>if T is a parameterized type S[T₁, T₂, ..., Tₙ], the union of the parts of S and T₁, ..., Tₙ,</li>
<li>otherwise, just T itself.</li>
</ul>
<p>As an example, consider the following type hierarchy:</p>
<pre><code class="scala">trait Foo[A]
trait Bar[A] extends Foo[A]
trait Baz[A] extends Bar[A]
trait X
trait Y extends X
</code></pre>

<p>만약 Bar[Y] 타입의 implicit value가 필요하다면 compiler는 아래와 같은 companion object에서 implicit definition을 찾을 것이다.</p>
<ul>
<li>Bar, because it is a part of Bar[Y],</li>
<li>Y, because it is a part of Bar[Y],</li>
<li>Foo, because it is a parent type of Bar,</li>
<li>and X, because it is a parent type of Y.</li>
<li>However, the Baz companion object will not be visited.</li>
</ul>
<h3 id="implicit-search-process">Implicit Search Process</h3>
<p>search process는 no candidate found 혹은 매칭되는 최소한 하나의 candidate를 결과를 만들어 낸다.</p>
<p>만약 no no available implicit definition matching 이라면 에러가 repot 된다.</p>
<pre><code class="scala">scala&gt; def f(implicit n: Int) = ()

scala&gt; f
       ^
error: could not find implicit value for parameter n: Int
</code></pre>

<p>반대로 둘 이상의 implicit definition이 eligibale 하다면 ambiguity가 report 된다.</p>
<pre><code class="scala">scala&gt; implicit val x: Int = 0

scala&gt; implicit val y: Int = 1

scala&gt; def f(implicit n: Int) = ()

scala&gt; f
       ^
error: ambiguous implicit values:
  both value x of type =&gt; Int
</code></pre>

<p>same type에 매칭되는 several implicit definitions가 있어도 하나를 특정 할 수 있다면 괜찮다.</p>
<p>A definition a: A is more specific than a definition b: B if:</p>
<ul>
<li>type A has more “fixed” parts,</li>
<li>or, a is defined in a class or object which is a subclass of the class defining b.</li>
</ul>
<p>Let’s see a few examples of priorities at work.</p>
<p>Which implicit definition matches the Int implicit parameter when the following method f is called?</p>
<pre><code class="scala">implicit def universal[A]: A = ???
implicit def int: Int = ???
def f(implicit n: Int) = ()
f
</code></pre>

<p>위의 경우에서 universal은 type paramter를 지니고 int는 아니기에, int가 more fixed parts를 갖고 이는 universal보다 먼저 고려된다. 그렇기 때문에 컴파일러가 int를 선택함에 있어 ambiguity가 없다.</p>
<p>아래와 같이 있을 때 implicit Int 파라미터를 갖는 f method는 어느 implicit definition에 매치 될까?</p>
<pre><code class="scala">trait A {
  implicit val x: Int = 0
}
trait B extends A {
  implicit val y: Int = 1
  def f(implicit n: Int) = ()
  f
}
</code></pre>

<p>y가 A를 extend하는 trait이므로 y가 A보다 more specific 하다. 그러므로 컴파일러가 y를 선택하는 것에 ambiguity는 없다.</p>
<h2 id="context-bounds">Context Bounds</h2>
<p>Syntactic sugar allows the omission of the implicit parameter list:</p>
<pre><code class="scala">def printSorted[A: Ordering](as: List[A]): Unit = {
  println(sort(as))
}
</code></pre>

<p>Type parameter A has one context bound: Ordering. This is equivalent to writing:</p>
<pre><code class="scala">def printSorted[A](as: List[A])(implicit ev1: Ordering[A]): Unit = {
  println(sort(as))
}
</code></pre>

<p>More generally, a method definition such as:</p>
<pre><code class="scala">def f[A: U₁ ... : Uₙ](ps): R = ...
</code></pre>

<p>Is expanded to:</p>
<pre><code class="scala">def f[A](ps)(implicit ev₁: U₁[A], ..., evₙ: Uₙ[A]): R = ...
</code></pre>

<h2 id="implicit-query">Implicit Query</h2>
<p>At any point in a program, one can query an implicit value of a given type by calling the implicitly operation:</p>
<pre><code class="scala">scala&gt; implicitly[Ordering[Int]]
res0: Ordering[Int] = scala.math.Ordering$Int$@73564ab0
</code></pre>

<p>Note that implicitly is not a special keyword, it is defined as a library operation:</p>
<pre><code class="scala">def implicitly[A](implicit value: A): A = value
</code></pre>

<h2 id="summary">Summary</h2>
<p>In this lesson we have introduced the concept of type-directed programming, a language mechanism that infers values from types.</p>
<p>There has to be a unique (most specific) implicit definition matching the queried type for it to be selected by the compiler.</p>
<p>Implicit values are searched in the enclosing lexical scope (imports, parameters, inherited members) as well as in the implicit scope of the queried type.</p>
<p>The implicit scope of type is made of implicit values defined in companion objects of types associated with the queried type.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../../js/base.js" defer></script>
        <script src="../../../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
