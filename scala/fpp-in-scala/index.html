<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Coursera/fpp-in-scala - sundicide</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Coursera/fpp-in-scala";
    var mkdocs_page_input_path = "scala/fpp-in-scala.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> sundicide</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Scala</span></p>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Coursera/fpp-in-scala</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#week1">Week1</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-11-programming-paradigms">Lecture 1.1 - Programming Paradigms</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#imperative-programming">Imperative Programming</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#what-is-a-theory">What is a theory</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#consequences-for-programming">Consequences for Programming</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#functional-programming">Functional Programming</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#functional-programming-language">Functional Programming Language</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#some-functional-programming-languages">Some functional programming languages</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#why-functional-programming">Why Functional Programming?</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#my-summary">my summary</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#substitution-model">substitution model</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#evaluation-stratigies">Evaluation Stratigies</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#value-definitions">Value Definitions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#nested-functions">Nested Functions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lexical-scoping">Lexical Scoping</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#tail-recursion">Tail Recursion</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#week2">Week2</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#higher-order-functions">Higher order functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#anonymous-function">Anonymous Function</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#currying">Currying</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#example-finding-fixed-points">Example: Finding Fixed Points</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#functions-as-return-values">functions as return values</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#functions-and-data">Functions and Data</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#classes">Classes</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#objects">Objects</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#more-fun-with-rationals">More Fun With Rationals</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#self-reference">Self Reference</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#preconditions">Preconditions</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#assertions">Assertions</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#constructors">Constructors</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#evaluation-and-operators">Evaluation and Operators</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#operators">Operators</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#precedence-rules">Precedence Rules</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#week3">Week3</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#class-hierarchies">Class Hierarchies</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#object-definitions">Object Definitions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#programs">Programs</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dynamic-binding">Dynamic Binding</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-32-how-classes-are-organized">Lecture 3.2 - How Classes Are Organized</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#packages">Packages</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#forms-of-imports">Forms of Imports</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#automatic-imports">Automatic Imports</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#traits">Traits</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#top-types">Top Types</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#the-nothing-type">The Nothing Type</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#exceptions">Exceptions</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#the-null-type">The Null Type</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-33-polymorphism">Lecture 3.3 - Polymorphism</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#type-parameter">Type Parameter</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#generic-functions">Generic Functions</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#type-inference">Type Inference</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#type-evaluation">Type Evaluation</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#polymorphism">Polymorphism</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#week4">Week4</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-41-objects-everywhere">Lecture 4.1 - Objects Everywhere</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#pure-object-orientation">Pure Object Orientation</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#standard-classes">Standard Classes</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#pure-booleans">Pure Booleans</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-42-functions-as-objects">Lecture 4.2 - Functions as Objects</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#expansion-of-function-calls">Expansion of Function Calls</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#functions-and-methods">Functions and Methods</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-43-subtyping-and-generics">Lecture 4.3 - Subtyping and Generics</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#covariance">Covariance</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-45-decomposition">Lecture 4.5 - Decomposition</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#decomposition">Decomposition</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#non-solution-type-tests-and-type-casts">Non-Solution: Type Tests and Type Casts</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#solution1-object-oriented-decomposition">Solution1: Object-Oriented Decomposition</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-46-pattern-matching">Lecture 4.6 - Pattern Matching</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#case-classes">Case Classes</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#pattern-matching">Pattern Matching</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-47-lists">Lecture 4.7 - Lists</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#the-list-type">The List Type</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#constructors-of-lists">Constructors of Lists</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#operations-on-lists">Operations on Lists</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#list-patterns">List Patterns</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#sorting-lists">Sorting Lists</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#week5">Week5</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-51-more-functions-on-lists">Lecture 5.1 - More Functions on Lists</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#list-methods1">List Methods(1)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#list-methods1_1">List Methods(1)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#implementations">Implementations</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-52-pairs-and-tuples">Lecture 5.2 - Pairs and Tuples</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#splitat-function">SplitAt Function</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#detour-pair-and-tuples">Detour: Pair and Tuples</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#the-tuple-class">The Tuple class</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-53-implicit-parameters">Lecture 5.3 - Implicit Parameters</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#making-sort-more-general">Making Sort more General</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#parametrization-with-ordered">Parametrization with Ordered</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#aside-implicit-parameters">Aside: Implicit Parameters</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#rules-for-implicit-parameters">Rules for Implicit Parameters</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-54-higher-order-list-functions">Lecture 5.4 - Higher-Order List Functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#map">Map</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#filtering">Filtering</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#variations-of-filter">Variations of Filter</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-55-reduction-of-lists">Lecture 5.5 - Reduction of Lists</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#reduceleft">ReduceLeft</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#a-shorter-way-to-write-functions">A Shorter Way To Write Functions</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#foldleft">FoldLeft</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#implementations-of-reduceleft-and-foldleft">Implementations of ReduceLeft and FoldLeft</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#foldright-and-reduceright">FoldRight and ReduceRight</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#difference-between-foldleft-and-foldright">Difference between FoldLeft and FoldRight</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-56-reasoning-about-concat">Lecture 5.6 - Reasoning About Concat</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-57-a-larger-equational-proof-on-lists">Lecture 5.7 - A Larger Equational Proof on Lists</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#week6">Week6</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-61-other-collections">Lecture 6.1 - Other Collections</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-62-combinatorial-search-and-for-expressions">Lecture 6.2 - Combinatorial Search and For-Expressions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-63-combinatorial-search-example">Lecture 6.3 - Combinatorial Search Example</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-64-maps">Lecture 6.4 - Maps</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lecture-65-putting-the-pieces-together">Lecture 6.5 - Putting the Pieces Together</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#conclusion">Conclusion</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../fpd-in-scala/">Coursera/fpd-in-scala</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">sundicide</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Scala &raquo;</li>
        
      
    
    <li>Coursera/fpp-in-scala</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="fpp-in-scala">fpp-in-scala</h1>
<h2 id="week1">Week1</h2>
<h3 id="lecture-11-programming-paradigms">Lecture 1.1 - Programming Paradigms</h3>
<p>functional Programming은 paradigm이다. classical imperative paradimg(Java or C)과 약간 다른.
scala에서는 이 2개의 paradigm을 합칠 수도 있다. 이는 다른 언어에서의 migration을 쉽게 해준다.</p>
<p>In science, a <code>paradigm</code> describes distinct concepts or thought patterns in some scientific discipline.</p>
<p>Main Programming Paradigms:
- imperative programming
- functional programming
- logic programming</p>
<p>object-oriented programming도 paradigm이라고 하는 사람들도 있지만 자신의 생각으로는 위 3개의 교차점에 있다고 생각한다.</p>
<h4 id="imperative-programming">Imperative Programming</h4>
<ul>
<li>modifying mutable variables</li>
<li>using assignments</li>
<li>and control structures such as if-then-else, loops, break, continue, return</li>
</ul>
<p>Von Neumann computer의 sequence를 이해하는 것은 imperative program을 이해하는 most common informal way이다.</p>
<blockquote>
<p>Processor &lt;------BUS ------&gt; Memory</p>
</blockquote>
<p>Problem: Scaling up. How can we avoid conceptualizing programs word by word?</p>
<p>high-level abstractions(collections, polynomials, geomtric shapes, strings, documents..)를 정의하는 테크닉이 필요하다.</p>
<p>Ideally: Develop theories of collections, shapes, strings, ...</p>
<h4 id="what-is-a-theory">What is a theory</h4>
<p>A theory consist of
- one or more data types
- operations on these types
- laws that describe the relationships between values and operations</p>
<p>보통 theory는 <code>mutations</code>를 describe하지 않는다!</p>
<p>mutation: identity는 유지하면서 something을 change하는 것이다.</p>
<h5 id="theories-without-mutations">Theories without mutations</h5>
<p>theory of polynomials</p>
<blockquote>
<p>(a<em>x + b) + (c</em>x + d) = (a+c)*x + (b+d)</p>
</blockquote>
<p>theory of strings</p>
<blockquote>
<p>(a ++ b) ++ c = a ++ (b ++ c)</p>
</blockquote>
<h4 id="consequences-for-programming">Consequences for Programming</h4>
<p>mathematical theroies를 따르면서 high-level concepts 구현을 하려면 mutation은 없어야 한다.
- theroies do not admit it
- mutation은 theories의 useful laws를 destoy 할 수 있다.</p>
<p>그러므로
- concentrate on defining theories for operators expressed as functions
- avoid mutations
- have powerful ways to abstract and compose functions</p>
<p>start of function programming means avoid mutations</p>
<h4 id="functional-programming">Functional Programming</h4>
<ul>
<li>In a restricted sense, FP means programming without mutable variables, assignments, loops, and other imperative control structures</li>
<li>In a wider sense, FP meas focusing on the functions</li>
<li>In particular, functions can be valuses that are produced, consumed, and composed</li>
<li>All this becomes easier in a functional language</li>
</ul>
<h4 id="functional-programming-language">Functional Programming Language</h4>
<ul>
<li>In a restricted sense, a functional programming language is one which does not have mutable variables, assignments, or imperative control structures.</li>
<li>In a wider sense, a functional programming language enables the construction of elegant programs that focus on functions.</li>
<li>In particular, functions in a FP language are first-class citizens. This means<ul>
<li>they can be defined anywhere, including inside other functions</li>
<li>like any other value, they can be passed as parameters to functions and returned as results</li>
<li>as for other values, there exists a set operators to compose functions</li>
</ul>
</li>
</ul>
<h4 id="some-functional-programming-languages">Some functional programming languages</h4>
<p>In the restricted sense:
- Pure Lisp, XSLT, XPath, XQuery, FP
- Haskell (without I/O Monad or UnsafePerformIO)</p>
<p>In the wider sense:
- Lisp, Scheme, Racket, Clojure ▶ SML, Ocaml, F#
- Haskell (full language)
- Scala
- Smalltalk, Ruby (!)</p>
<h4 id="why-functional-programming">Why Functional Programming?</h4>
<p>Functional Programming is becoming increasingly popular because it offers the following benfits.
- simpler reasoning principles
- better modularity
- good for exploiting parallelism for multicore and cloud computing.</p>
<h4 id="my-summary">my summary</h4>
<p>우리는 수학을 배우면서 mutable variables를 배운 적이 없다.</p>
<p>1 + 1 = 2이고 a + b = 3 이라면 그냥 3인 것이다.
오늘은 a + b = 3 이었는데 내일은 a + b = 4일 순 없었다.
(ax^2 + bx + c 는 여러 값이 될 수 있겠지만)</p>
<p>하지만 imperative programming에서는 자연스러운 개념이다.
int a = 1;
int b = 2;
a + b = 3;</p>
<p>a = 4;
a + b = 6;</p>
<p>왜 수학적인 원칙을 꺼내 들었냐?
module화 때문이다.</p>
<p>프로그램이 복잡해지면서 모듈화는 필수이다.
잘 된 모듈화란 무엇일까? 항상 동일한 결과를 리턴하는 모듈일 것이다.</p>
<p>map 함수를 생각해보면 어느 타입에 상관없이
List[U]를 리턴한다.</p>
<p>이런 수학적 원칙들은 mutable variables를 인정하지 않는다. 그렇기에 functional programming language에 잘 맞는다.</p>
<p>fp는 이런 모호함을 제거함으로서 원칙을 보다 잘 구현하고 모듈화 하기 좋으며 multicore와 cloud computing 환경에서 병렬처리를 잘 할 수 있게 해준다.</p>
<hr />

<h2 id="substitution-model">substitution model</h2>
<ul>
<li>함수의 argument를 왼쪽부터 모두 평가</li>
<li>함수의 오른쪽부터 교체</li>
</ul>
<p>-&gt; 모든 Expression에 사용 가능 , No side effect</p>
<p>foundation of functional programming인 람다 calculus에 formalized 되어있다.</p>
<p>모든 Expr이 reduce to a value? (X)</p>
<p>아래와 같은 예가 있다.</p>
<pre><code class="scala">def loop: Int = loop
</code></pre>

<h3 id="evaluation-stratigies">Evaluation Stratigies</h3>
<p>CBV(Call By Value), CBN(Call By Name)
- CBV: 모든 args는 한 번만 평가한다는 장점
- CBN: 호출 될 때까지 not evaluted된다는 장점</p>
<p>만약 CBV가 종료된다면 CBN도 종료된다? (O)
반대로 CBN이 종료된다면 CBV도 종료된다? (X)</p>
<p>scala에서 CBN을 쓰는 방법은 parameter에 <code>=&gt;</code>를 붙이면 된다.</p>
<pre><code class="scala">def myFunc(a:=&gt; Int) = a
</code></pre>

<h3 id="value-definitions">Value Definitions</h3>
<pre><code class="scala">val x = 2
val y = square(x) // 바로 평가된다.


def loop: Boolean = loop

def x = loop // (O) def는 호출될때 평가된다.
val x = loop // (X) Error

def and(x: Boolean, y: Boolean) =
  if (x) y else false

and(false, loop) // (X) Error

def and2(x: Boolean, y:=&gt; Boolean) =
  if (x) y else false
and2(false, loop) // false
</code></pre>

<h3 id="nested-functions">Nested Functions</h3>
<p>small func로 분리하는 것. good FP styles
sqrtIter, imporve 같은 함수들은 외부에 공개(direct 호출) 하고 싶지 않을 수 있다.</p>
<p>이러한 보조 함수들을 내부 함수로 둠으로써 name-space pollution을 방지할 수 있다.</p>
<pre><code class="scala">def sqrt(x: Double) = {
  def improve
  def sqrtIter
}
</code></pre>

<h3 id="lexical-scoping">Lexical Scoping</h3>
<p>outer block에 있는 definitions는 inside block에서 visible하다.</p>
<p>보통 문장 라인 끝 <code>;</code>는 optional이다.
다만 한 문장에 여러 expr을 표현할 때는 필수 이다.</p>
<pre><code class="scala">val y = x + 1; y + y
</code></pre>

<h3 id="tail-recursion">Tail Recursion</h3>
<p>calls itself as its last action.
the function's stack frame can be reused
(one stack frame이 필요하며, tail calls 라고 함)</p>
<p><code>@tailrec</code> annotation을 함수 위에 추가하면 해당 함수가 tail recur 하지 않을 시 오류가 발생한다.</p>
<p>아래의 factorial 함수는 tailrc 함수가 아니며 gcd는 tailrec 함수이다.</p>
<pre><code class="scala">def gcd(a: Int, b: Int): Int =
  if (b == 0) a else gcd(b, a % b)

def factorial(n: Int): Int =
  if (n == 0) 1 else n * factorial(n - 1)
</code></pre>

<p>그 차이는 gcd는 스텝을 진행을 계속 하더라도 본인 호출만 계속 하게 되지만 factorial 같은 경우에는 좌측이 계속 늘어난다</p>
<blockquote>
<p>4 * factorial(3)</p>
</blockquote>
<p>이를 tail recursive 하게 변경하면 아래와 같다.</p>
<pre><code class="scala">def factorial(n: Int): Int = {
  @tailrec
  def loop(acc: Int, n: Int): Int =
    if (n == 0) acc
    else loop(acc * n, n -1)
  loop(1, n)
}
</code></pre>

<p>Donal Knuth said premature optimization is the source of the evil</p>
<h2 id="week2">Week2</h2>
<h3 id="higher-order-functions">Higher order functions</h3>
<p>pass functions as arguments and retun them as results.</p>
<p>functional languages treat functions as first-class values.
= like any other value, a function can be passed as a parameter and returned as a result.</p>
<p>provides a flexible way to compose program.</p>
<h4 id="anonymous-function">Anonymous Function</h4>
<p>함수를 parameter로 전달하다보면 many small function을 만들게 된다. 그렇게 되면 각각의 naming을 정하는 것은 어렵게 된다.
=&gt; anonymous function을 사용한다.</p>
<pre><code class="scala">def str = &quot;abc&quot;; println(str)

println(&quot;abc&quot;)
</code></pre>

<p>위에는 str 변수를 정의해서 호출했고 아래는 정의 없이 사용 했다.
이것이 가능한 이유는 뭘까?
=&gt; str은 literals 이기 때문이다.</p>
<p>마찬가지로 이름 없이 함수를 쓰면 function literals가 된다.
= anonymous functions</p>
<pre><code class="scala">// cube anonymous func
(x: Int) =&gt; x * x * x
</code></pre>

<p><code>(x: Int)</code>는 parameter
<code>x * x  * x</code>는 body</p>
<pre><code class="scala">def sum(f: Int =&gt; Int, a: Int, b: Int): Int = {
  @tailrec
  def loop(a: Int, acc: Int): Int = {
    if (a &gt; b) acc
    else loop(a + 1, f(a) + acc)
  }
  loop(a, 0)
}
def sumInts(a: Int, b: Int) = sum(x =&gt; x, a, b)

def sumCubes(a: Int, b: Int) = sum(x =&gt; x * x * x, a, b)
</code></pre>

<h3 id="currying">Currying</h3>
<p>아래 함수를 더 짧게 할 수는 없을까?</p>
<pre><code class="scala">def sumInts(a: Int, b: Int) = sum(x =&gt; x, a, b)
</code></pre>

<pre><code class="scala">def sum()
</code></pre>

<pre><code class="scala">def sum(f: Int =&gt; Int)(a: Int, b: Int): Int =
  if (a &gt; b) 0 else f(a) + sum(f)(a + 1, b)

def product(f: Int =&gt; Int)(a: Int, b: Int): Int =
  if (a &gt; b) 1
  else f(a) * product(f)(a + 1, b)
</code></pre>

<p>위와 같은 스타일의 definition과 function을 currying이라고 부른다. Haskell Brooks Curry의 이름을 딴 네이밍이다.
Idea는 그 보다 전인 Schonfinkel과 Frege에 의해서 나왔지만 currying이란 네임으로 굳어졌다.</p>
<h3 id="example-finding-fixed-points">Example: Finding Fixed Points</h3>
<p>A number x is called a fixed point(고정 점) of a function f if</p>
<blockquote>
<p>f(x) = x</p>
</blockquote>
<p>예로 f: x =&gt; 1 + x/2 라 할 때 fixed point는 2이다.
f(2) = 2이므로</p>
<p>몇몇 함수들은 f를 반복적으로 수행함으로서 fixed point를 찾을 수 있다.</p>
<blockquote>
<p>x, f(x), f(f(x)), f(f(f(x))), ...</p>
</blockquote>
<p>initial estimate로 시작해서 f를 반복적으로 수행하다보면 더 이상 변하지 않는 값 혹은 변경이 충분히 적어졌을 때의 값을 fixed point라 부를 수 있다.</p>
<pre><code class="scala">import math.abs

val tolerance = 0.0001
def isCloseEnough(x: Double, y: Double): Boolean =
  abs((x - y) / x) / x &lt; tolerance

def fixedPoint(f: Double =&gt; Double)(firstGuess: Double) = {
  @tailrec
  def iterate(guess: Double): Double = {
    val next = f(guess)
    if (isCloseEnough(guess, next)) next
    else iterate(next)
  }
  iterate(firstGuess)
}
fixedPoint(x =&gt; 1 + x/2)(1) // 1.9975

def sqrt(x: Double) = fixedPoint(y =&gt; x / y)(1)
sqrt(2) // 무한 loop
</code></pre>

<p>위의 예에서 sqrt(2)를 수행하면 무한 loop가 발생한다.
1과 2 를 계속 반복한다
이를 해결 하기 위해서는 첫 번째 계산 값과 두 번째 계산 값의 평균을 구하면 된다.</p>
<pre><code class="scala">def sqrt(x: Double) =
  fixedPoint(y =&gt; (y + x / y) / 2)(1)
</code></pre>

<h4 id="functions-as-return-values">functions as return values</h4>
<p>위의 예제에서 평균을 통해 안정화시키는 기술은 추상화 될 수 있다.</p>
<pre><code class="scala">def averageDamp(f: Double =&gt; Double)(x: Double) =
  (x + f(x)) / 2
def sqrt3(x: Double) =
  fixedPoint(averageDamp(y =&gt; x / y))(1)
</code></pre>

<p>Higher Order Function이 항상 옳은 것은 아니며 적절 할 때 사용해야 한다.</p>
<h3 id="functions-and-data">Functions and Data</h3>
<h4 id="classes">Classes</h4>
<pre><code class="scala">class Rational(x: Int, y: Int):
  def numer = x
  def denom = y
</code></pre>

<p>위 정의는 two entities를 생성한다.
- Rational 이라는 이름의 new type
- 이 type의 element를 만들기 위한 Rational constructo</p>
<p>스칼라는 types과 value의 names를 <code>different namespace</code>에 보관하기 때문에 충돌을 걱정할 필요 없다.</p>
<h4 id="objects">Objects</h4>
<p>elements of a class type을 objects라고 부른다.
class 의 생성자를 calling 함으로서 object를 만들 수 있다.</p>
<pre><code class="scala">Rational(1, 2)
</code></pre>

<p>아래와 같이 class내 member에 접근 가능하다</p>
<pre><code class="scala">val x = Rational(1 ,2)
x.numer
x.denom
</code></pre>

<pre><code class="scala">object rationals {
  val x = new Rational(1, 3)
  val y = new Rational(5, 7)
  val z = new Rational(3, 2)

  x.add(y).mul(z)
}
class Rational(x: Int, y: Int) {
  def numer = x
  def denom = y

  def add(r: Rational) =
    new Rational(numer * r.denom + r.numer * denom,
      denom * r.denom)

  def mul(r: Rational) =
    new Rational(numer * r.numer,
      denom * r.denom)

  def neg = new Rational(-numer, denom)

  def sub(r: Rational) = add(r.neg)

  override def toString = s&quot;$numer/$denom&quot;
}

</code></pre>

<h3 id="more-fun-with-rationals">More Fun With Rationals</h3>
<p>Client's view에서는 내부가 어떻게 동작하던지 동일하게 보인다.</p>
<p>without affecting client를 하면서 다른 구현을 선택하는 것을 <code>data abstraction</code>이라고 한다.
S/E에서의 cornerstone이다.</p>
<h4 id="self-reference">Self Reference</h4>
<p>inside of a class, <code>this</code>는 현재 실행 중인 method내에서의 object를 의미한다</p>
<h4 id="preconditions">Preconditions</h4>
<p><code>require</code>로 class에 조건을 추가할 수 있다.
조건에 맞지 않으면 IllegalArgumentException이 발생하며 추가한 에러 메세지가 출력된다.</p>
<h4 id="assertions">Assertions</h4>
<p>require와 비슷한 의미이다.
require와 동일하게 condtion과 optional message string을 받는다.</p>
<pre><code class="scala">val x = sqrt(y)
assert(x &gt;= 0)
</code></pre>

<p>fail일 경우 assert는 require와 달리 AssertionError를 발생한다.</p>
<ul>
<li>require는 함수 호출자에게 precondition을 강요할 때 쓰인다</li>
<li>assert는 함수 자신이 체크 할 때 사용한다.</li>
</ul>
<h4 id="constructors">Constructors</h4>
<p>모든 class는 primary constructor(기본 생성자)가 암시적으로 있다.
- class의 모든 paramters를 받고
- class body의 모든 statement를 실행한다.</p>
<p>Java 같이 여러 생성자를 갖는 것도 가능하다.</p>
<pre><code class="scala">object rationals {
  val x = new Rational(1, 3)
  val y = new Rational(5, 7)
  val z = new Rational(3, 2)

  x.add(y).mul(z)
  y.add(y)
  x.less(y)
  x.max(y)
  new Rational(2)
}
class Rational(x: Int, y: Int) {
  require(y != 0, &quot;denominator must be nonezero&quot;)

  def this(x: Int) = this(x, 1) // 여기에서의 this는 constructor 의미로 쓰인다.

  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
  private val g = gcd(x, y) // val로 선언했기에 바로 평가되서 다음 부턴 계산을 안하고 재사용한다.
  def numer = x / g
//    def numer = x / gcd(x,y) // 만약 이와 같이 선언 하면 매번 gcd를 계산해야 한다. 계산 리소스가 크고 가끔 호출될 때 사용하면 좋다.
  def denom = y / g

  def less(that: Rational) = numer * that.denom &lt; that.numer * denom
  def max(that: Rational) = if (this.less(that)) that else this

  def add(r: Rational) =
    new Rational(numer * r.denom + r.numer * denom,
      denom * r.denom)

  def mul(r: Rational) =
    new Rational(numer * r.numer,
      denom * r.denom)

  def neg = new Rational(-numer, denom)

  def sub(r: Rational) = add(r.neg)

  override def toString = s&quot;$numer/$denom&quot;
}

</code></pre>

<hr />

<h3 id="evaluation-and-operators">Evaluation and Operators</h3>
<h4 id="operators">Operators</h4>
<h5 id="infix-notation">Infix Notation</h5>
<p>parameter를 갖는 모든 메소드는 infix operaotr처럼 사용할 수 있다.</p>
<p>r add s           r.add(s)
r less s          r.less(s)
r max s           r.max(s)</p>
<h5 id="relaxed-identifiers">Relaxed Identifiers</h5>
<p>operaotr는 identifier로 사용될 수 있다.
- 영문자: 문자로 시작하고, 뒤에는 문자 혹은 숫자가 올 수 있다.
- Symbolic: operator symbol로 시작해서, 다른 심볼이 뒤에 올 수 있다.
- <code>_</code> 문자는 문자로 카운트 된다
- 영문자 identifiers는 underscore로 끝날 수 있고 뒤에 다른 operator symbols가 붙을 수 있다.
* 만약 끝이 symbol들로 끝나면 뒤에 타입을 위한 <code>:</code> 과 한 칸 띄워야 한다.</p>
<p>examples
- x1
- *
- +?%&amp;
- vector_++
- counter_=</p>
<p>-a 처럼 빼기가 아니라 마이너스 operator를 추가하고 싶다면 아래와 같이 해야 한다.
(<code>unary_</code> 가 앞에 붙어야 하고 <code>:</code>과 한칸 띄워 써야 한다.)</p>
<pre><code class="scala">def unary_- : Rational = new Rational(-numer, denom)
</code></pre>

<h4 id="precedence-rules">Precedence Rules</h4>
<p>연산자 우선순위.
첫 번째 문자에 따라 결정된다.
Java혹은 C와 차이 없다.</p>
<p>1번이 가장 낮은 순위이다.</p>
<ol>
<li>(all letters)</li>
<li>|</li>
<li>^</li>
<li>&amp;</li>
<li>&lt; &gt;</li>
<li>= !</li>
<li>:</li>
<li>
<ul>
<li>-</li>
</ul>
</li>
<li>
<ul>
<li>/ %</li>
</ul>
</li>
<li>(all other special values)</li>
</ol>
<pre><code class="scala">class Rational(x: Int, y: Int) {
  require(y != 0, &quot;denominator must be nonezero&quot;)

  def this(x: Int) = this(x, 1) // 여기에서의 this는 constructor 의미로 쓰인다.

  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
  private val g = gcd(x, y) // val로 선언했기에 바로 평가되서 다음 부턴 계산을 안하고 재사용한다.
  def numer = x / g
//    def numer = x / gcd(x,y) // 만약 이와 같이 선언 하면 매번 gcd를 계산해야 한다. 계산 리소스가 크고 가끔 호출될 때 사용하면 좋다.
  def denom = y / g

//    def less(that: Rational) = numer * that.denom &lt; that.numer * denom
  def &lt; (that: Rational) = numer * that.denom &lt; that.numer * denom
  def max(that: Rational) = if (this.&lt;(that)) that else this

  def +(r: Rational) =
    new Rational(numer * r.denom + r.numer * denom,
      denom * r.denom)

  def mul(r: Rational) =
    new Rational(numer * r.numer,
      denom * r.denom)

  def unary_- : Rational = new Rational(-numer, denom)

  def -(that: Rational) = this + -that

  override def toString = s&quot;$numer/$denom&quot;
}
</code></pre>

<h2 id="week3">Week3</h2>
<h3 id="class-hierarchies">Class Hierarchies</h3>
<p>실제 메소드는 runtime type에 의존한다. 이를 dynamic binding이라고 한다.
이는 OOP에 기본 요소이다.</p>
<p>아래 함수는 abstract class이다.</p>
<pre><code class="scala">abstract class IntSet {
  def incl(x: Int): IntSet
  def contains(x: Int): Boolean
}
</code></pre>

<p>추상 클래스는
- 구현체가 없는 멤버를 포함할 수 있다.
- new operator를 사용한 인스턴스 생성을 할 수 없다.</p>
<pre><code class="scala">abstract class IntSet {
  def incl(x: Int): IntSet
  def contains(x: Int): Boolean
}

class NonEmpty(elem: Int, left: IntSet, right: IntSet) extends IntSet {
  override def incl(x: Int): IntSet =
    if (x &lt; elem) new NonEmpty(elem, left incl x, right)
    else if (x &gt; elem) new NonEmpty(elem, left, right incl x)
    else this

  override def contains(x: Int): Boolean =
    if (x &lt; elem) left contains x
    else if (x &gt; elem) right contains x
    else true

  override def toString = &quot;{&quot; + left + elem + right + &quot;}&quot;
}

class Empty extends IntSet {
  override def incl(x: Int) = new NonEmpty(x, new Empty, new Empty)

  override def contains(x: Int) = false
  override def toString = &quot;.&quot;
}


val t1 = new NonEmpty(3, new Empty, new Empty)
val t2 = t1 incl 4
</code></pre>

<p>위의 예에서 IntSet은 Empty와 NonEmpty의 superclass이다.
Empty와 NonEmpty는 IntSet의 subclasses이다.
스칼라에서 superclass가 없으면 java.lang에 있는 Java standard class Object 를 상속 받는다.
클래스의 direct or indirect superclass를 base classes라고 한다.
NonEmpty와 IntSet의 base classes는 Object이다.</p>
<p>non-abstract definition을 redfine할 때는 override keyword를 써줘야 한다.</p>
<pre><code class="scala">abstract class Base {
  def foo = 1
  def bar: Int
}

class Sub extends Base {
  override def foo = 2
  def bar = 3
}
</code></pre>

<h3 id="object-definitions">Object Definitions</h3>
<p>위의 예에서 유저가 많은 EmptySet을 만들게 되면 문제가 발생한다.
그래서 이를 object로 선언하는 것이 낫다.</p>
<pre><code class="scala">object Empty extends IntSet {
  def incl(x: Int) = new NonEmpty(x, new Empty, new Empty)
  def contains(x: Int) = false
}
</code></pre>

<p>이렇게 하면 Empty라는 이름의 singleton object가 만들어 진다.
이로써 다른 Empty 인스턴스는 만들어질 수 없다.
Singleton Object는 values 이므로, Empty는 바로 평가된다.</p>
<h3 id="programs">Programs</h3>
<p>Scala에서 standalone application을 만드는 것은 가능하다.
main method를 포함하는 object를 만들면 된다.</p>
<pre><code class="scala">object Hello {
  def main(args: Array[String]) = println(&quot;hello world!&quot;)
}
</code></pre>

<p>프로그램이 컴파일 되고 나면 아래의 커맨드로 실행할 수 있다.</p>
<pre><code class="bash">&gt; scala Hello
</code></pre>

<h3 id="dynamic-binding">Dynamic Binding</h3>
<p>code invoked by a method call depends on the runtime of the object that contains the method</p>
<p>ex)</p>
<pre><code class="scala">Empty contains 1
</code></pre>

<p>-&gt; false</p>
<h3 id="lecture-32-how-classes-are-organized">Lecture 3.2 - How Classes Are Organized</h3>
<h4 id="packages">Packages</h4>
<p>Classes와 objects는 package안에 구성된다된</p>
<p>package에 속하는 class, object는 소스 파일의 최상단에 package를 써야 한다.</p>
<pre><code class="scala">package progfun.examples

object Hello { ... }
</code></pre>

<p>아래와 같이 프로그램을 실행할 수 있다.</p>
<pre><code class="bash">&gt; scala progfun.examples.Hello
</code></pre>

<h4 id="forms-of-imports">Forms of Imports</h4>
<pre><code class="scala">import week3.Rational // named imports
import week3.{Rational, Hello} // named imports
import week3._ // wildcard import
</code></pre>

<h4 id="automatic-imports">Automatic Imports</h4>
<ul>
<li>All members of package scala</li>
<li>All members of package java.lang</li>
<li>All members of the singleton object scala.Predef</li>
</ul>
<p>Int: scala.Int
Boolean: scala.Boolean
Object : java.lang.Object
require: scala.Predef.require
assert: scala.Predef.assert</p>
<h4 id="traits">Traits</h4>
<p>Java 처럼 Scala는 오직 하나의 superclass를 가질 수 있다.(Single Inheritance)
하지만 여러개의 supertypes를 갖고 싶다면 어떻게 할까?
traits를 사용하면 된다.
trait은 abstract class처럼 정의 하면서 trait 키워드를 쓰면 된다를</p>
<pre><code class="scala">trait Planar {
  def height: Int
  def width: Int
  def surface = height * width
}
</code></pre>

<pre><code class="scala">class Square extends Shape with Planar with Movable ...
</code></pre>

<p>trait은 Java의 interface와 비슷하지만 더 강력하다.
fields와 concrete methods(정의된 메소드)를 가질 수 있기 때문이다.</p>
<p>하지만 trait은 (value) parameters를 가질 수 없다. 이는 클래스만 가능하다.</p>
<p><img alt="" src="../scala%20class%20hierarchy.png" /></p>
<h4 id="top-types">Top Types</h4>
<p>Any: The base type of all types. Methods: '==', '!=', 'equals', 'hashCode', 'toString
AnyRef: The base type of all reference types; Alias of 'java.lang.Object'
AnyVal: The base type of all primitive types</p>
<h4 id="the-nothing-type">The Nothing Type</h4>
<p>Nothing은 Scala type hierarchy에서 최 하단에 있다.
type Nothing에는 value가 없다.
왜 쓰일까?
- To signal abnormal termination
- As an element type of empty collection</p>
<h4 id="exceptions">Exceptions</h4>
<p>자바와 유사하다</p>
<pre><code class="scala">throw Exc
</code></pre>

<p>이 expr의 type은 Nothing이다.</p>
<p>example</p>
<pre><code class="scala">def error(msg: String) = throw new Error(msg)

error(&quot;test&quot;)
</code></pre>

<h4 id="the-null-type">The Null Type</h4>
<p>every reference class type은 null 값을 갖는다.
null의 타입은 Null 이다.
Null은 Object를 상속받는 모든 클래스의 subtype이다.
하지만 AnyVal의 subtypes과는 incompativle 하다.</p>
<pre><code class="scala">val x = null // x: Null
val y: String = null // y: String
val z: Int = null // error: type mismatch
</code></pre>

<h3 id="lecture-33-polymorphism">Lecture 3.3 - Polymorphism</h3>
<h4 id="type-parameter">Type Parameter</h4>
<p>여러 타입에 대응할 수 있는 타입이다.</p>
<pre><code class="scala">trait List[T]
class Cons[T](val head: T, val tail: List[T]) extends List[T]
class Nil[T] extends List[T]
</code></pre>

<p>타입 파라미터는 square brackets 안에 쓰인다.</p>
<h4 id="generic-functions">Generic Functions</h4>
<p>classes처럼 function에도 type parameter를 사용할 수 있다.</p>
<pre><code class="scala">def singleton[T](elem: T) = new Cons[T](elem, new Nil[T])

singleton[Int](1)
singleton[Boolean](true)
</code></pre>

<h4 id="type-inference">Type Inference</h4>
<p>스칼라는 function call의 arguments로 부터 parameter의 옳은 타입을 추측할 수 있다.
그렇기에 대부분의 경우에서 type parameters는 안써도 된다.</p>
<pre><code class="scala">singleton(1)
singleton(true)
</code></pre>

<h4 id="type-evaluation">Type Evaluation</h4>
<p>스칼라에서 Type parameter는 evaluation에 영향을 끼치지 않는다.
모든 type parameters와 type arguments는 프로그램을 평가하기 전에 제거된다.
이를 <code>type erasure</code>라고 부른다.</p>
<p>Java, Scala, Haskell, ML, OCaml에서는 type erasure를 사용한다.
하지만 C++, C#, F# 같은 언어는 run time시에도 type parameter를 유지한다.</p>
<h4 id="polymorphism">Polymorphism</h4>
<p>function type comes "in many forms"
- function이 여러 타입의 argument에 적용될 수 있다
- 타입이 여러 타입의 인스턴스를 가질 수 있다.</p>
<p>폴리몰피즘의 두 가지 형태
- subtyping: instances of subclass 는 base class로 전달 될 수 있다.
- generic: function 혹은 클래스의 instance는 type paramterization으로 만들 수 있다.</p>
<h2 id="week4">Week4</h2>
<h3 id="lecture-41-objects-everywhere">Lecture 4.1 - Objects Everywhere</h3>
<h4 id="pure-object-orientation">Pure Object Orientation</h4>
<p>A pure object-oriented language is one in which every value is an object</p>
<p>스칼라는 pure object-oriented language인가?</p>
<h4 id="standard-classes">Standard Classes</h4>
<p>스칼라에서 Int 혹은 Boolean 같은 타입들은 특별취급을 받지 않는다.
다른 클래스들과 마찬가지로 scala 패키지 안에 정의된 것이다.</p>
<h4 id="pure-booleans">Pure Booleans</h4>
<p>Boolean type은 JVM의 primitive type boolean이다.
하지만 이를 클래스로도 정의할 수 있다.</p>
<pre><code class="scala">package idealized.scala
abstract class Boolean {
  def ifThenElse[T](t: =&gt; T, e: =&gt; T): T

  def &amp;&amp; (x: =&gt; Boolean): Boolean = ifThenElse(x, false)
  def || (x: =&gt; Boolean): Boolean = ifThenElse(true, x)
  def unary_!: Boolean            = ifThenElse(x, false)

  def == (x: Boolean): Boolean    = ifThenElse(x, x.unary_!)
  def !&amp; (x: Boolean): Boolean    = ifThenElse(x.unary_!, x)
  ...
}

object true extends Boolean {
  def ifThenElse[T](t: =&gt; T, e: =&gt; T) = t
}

object false extends Boolean {
  def ifThenElse[T](t: =&gt; T, e: =&gt; T) = e
}
</code></pre>

<h3 id="lecture-42-functions-as-objects">Lecture 4.2 - Functions as Objects</h3>
<p>function values는 object로 취급된다.</p>
<p>function type A =&gt; B는 class scala.Function1[A,B]의 축약이다.</p>
<pre><code class="scala">package scala
trait Function1[A, B] {
  def apply(x: A): B
}
</code></pre>

<p>그러므로 functions는 objects이다 apply methods를 갖는.</p>
<p><code>(x: Int) =&gt; x * x</code>는 아래와 같이 확장된다.</p>
<pre><code class="scala">{
  class AnonFun extends Function1[Int, Int] {
    def apply(x: Int) = x * x
  }
  new AnnonFun
}
</code></pre>

<p>또는</p>
<pre><code class="scala">new Function1[Int, Int] {
  def apply(x: Int) = x * x
}
</code></pre>

<h4 id="expansion-of-function-calls">Expansion of Function Calls</h4>
<p>f(a, b)는 아래와 같이 확장된다.
<code>f.apply(a, b)</code></p>
<pre><code class="scala">val f = (x: Int) =&gt; x * x
f(7)
</code></pre>

<p>은 아래와 같이 확장된다.</p>
<pre><code class="scala">val f = new Function1[Int, Int] {
  def apply(x: Int) =&gt; x * x
}
f.apply(7)
</code></pre>

<h4 id="functions-and-methods">Functions and Methods</h4>
<p>아래와 같은 메소드는 그 자체로는 function value가 아니다.</p>
<pre><code class="scala">def f(x: Int): Boolean = ...
</code></pre>

<p>하지만 f는 Function type이 기대되는 곳에서 사용되기 때문에 자동적으로 function value로 변환된다.</p>
<pre><code class="scala">(x: Int) =&gt; f(x)
</code></pre>

<h3 id="lecture-43-subtyping-and-generics">Lecture 4.3 - Subtyping and Generics</h3>
<p>Type Bounds</p>
<p>만약 <code>assertAllPos</code>라는 method가 있다고 하자.</p>
<ul>
<li>IntSet을 받고</li>
<li>만약 모든 엘리먼트가 positive라면 IntSet을 리턴한다.</li>
<li>그 외에는 exception을 던진다.</li>
</ul>
<p><code>def assertAllPos(s: IntSet): IntSet</code>
이 코드는 모든 경우를 포함하지 않는다.
nonEmpty를 파라미터로 준다면 NonEmpty 혹은 Error가 반환되고 Empty를 파라미터로 보내면 Empty가 반환되기 떄문이다.
정확한 IntSet이 아닌 상속 Empty와 NonEmpty는 하위 클래스이다.</p>
<pre><code class="scala">def assertAllPos[S &lt;: IntSet](r: S): S
</code></pre>

<p>여기에서 <code>&lt;: IntSet</code>은 type parameter S의 <code>upper bound</code>이다.</p>
<ul>
<li>S &lt;: T means: S는 T의 subtype이다</li>
<li>S &gt;: T means: S는 T의 supertype이다. 또는 T는 S의 subtype이다.</li>
</ul>
<p><code>[S &gt;: NonEmpty]</code> 일때
S는 NonEmpty, IntSet, AnyRef, Any가 될 수 있다.</p>
<p>이 두개를 섞는 것도 가능하다</p>
<p><code>[S &gt;: NonEmpty &lt;: IntSet]</code></p>
<h4 id="covariance">Covariance</h4>
<p>subtyping과 type parameter를 사용할 때 고려해야할 사항이 있다.</p>
<p><code>NonEmpty &lt;: IntSet</code> 일때</p>
<p><code>List[NonEmpty] &lt;: List[IntSet]</code> 인가?
우리는 이런 것을 공변(covariant)라고 부른다.</p>
<p>Java에선 되지만 스칼라에선 안된다.</p>
<p>아래와 같은 Java Code를 보자</p>
<pre><code class="java">NonEmpty[] a = new NonEmpty[]{new NonEmpty(1, Empty, Empty)}
IntSet[] b = a
b[0] = Empty
NonEmpty s = a[0]
</code></pre>

<p>3번 째 라인에서 runtime error(ArrayStoreException)가 발생한다.
NonEmpty에 Empty를 넣으려고 시도하기 때문이다.</p>
<p>그렇기 때문에 Scala에선 List Convariance가 안된다.</p>
<pre><code class="scala">val a: Array[NonEmpty] = Array(new NonEmpty(1, Empty, Empty))
val b: Array[IntSet] = a
b(0) = Empty
val s: NonEmpty = a(0)
</code></pre>

<p>위에서 2번쨰 라인에서가 error가 발생한다.
Scala에선 List Convariance가 안되기 때문이다.</p>
<h3 id="lecture-45-decomposition">Lecture 4.5 - Decomposition</h3>
<h4 id="decomposition">Decomposition</h4>
<p>예를들어 수학 연산을 위한 작은 인터프리터를 만든다고 하자.
간단하게 하기 위해 numbers와 additions만 한다.
Expressions는 class hierarchy로 표현될 수 있고
기본 trait인 Expr과 two subclasses인 Number와 Sum으로 구성할 수 있다.</p>
<pre><code class="scala">trait Expr {
  def isNumber: Boolean
  def isSum: Boolean
  def numValue: Int
  def leftOp: Expr
  def rightOp: Expr
}
class Number(n: Int) extends Expr {
  def isNumber: Boolean = true
  def isSum: Boolean = false
  def numValue: Int = n
  def leftOp: Expr = throw new Error(&quot;Number.leftOp&quot;)
  def rightOp: Expr = throw new Error(&quot;Number.rightOp&quot;)
}
class Sum(e1: Expr, e2: Expr) extends Expr {
  def isNumber: Boolean = false
  def isSum: Boolean = true
  def numValue: Int = throw new Error(&quot;Sum.numValue&quot;)
  def leftOp: Expr = e1
  def rightOp: Expr = e2
}

def eval(e: Expr): Int = {
  if (e.isNumber) e.numValue
  else if (e. isSum) eval(e.leftOp) + eval(e.rightOp)
  else throw new Error(&quot;Unknown expression&quot; + e)
}
</code></pre>

<p>만약 Expr에 새로운 메서드를 추가한다고 가정하면 이를 확장하는 class들에도 모두 구현을 추가해야 한다.
새로운 클래스를 추가할수록 계속해서 많은 메서드를 추가해야 한다.</p>
<h4 id="non-solution-type-tests-and-type-casts">Non-Solution: Type Tests and Type Casts</h4>
<pre><code class="scala">def isInstanceOf[T]: Boolean // check whether this object's type conforms to 'T'
def asInstanceOf[T]: T       // treat this object as an instance of type 'T'
                             // throws 'ClassCastException' if it isn't
</code></pre>

<pre><code class="scala">def eval(e: Expr): Int =
  if (e.isInstanceOf[Number])
    e.asInstanceOf[Number].numValue
  else if (e.isInstanceOf[Sum])
    eval(e.asInstanceOf[Sum].leftOp) +
    eval(e.asInstanceOf[Sum].rightOp)
  else throw new Error(&quot;Unknown expression &quot; + e)
</code></pre>

<p>no need for classification methods, access 메소드를 필요할 때만 사용할 수 있다는 장점이 있다.
low-level, potentially unsafe하다는 단점이 있다.</p>
<p>type cast를 수행했을 때 오류가 발생하는 것을 runtime에서 알 수 있다.</p>
<h4 id="solution1-object-oriented-decomposition">Solution1: Object-Oriented Decomposition</h4>
<pre><code class="scala">trait Expr {
  def eval: Int
}
class Number(n: Int) extends Expr {
  def eval: Int = n
}
class Sum(e1: Expr, e2: Expr) extends Expr {
  def eval: Int = e1.eval + e2.eval
</code></pre>

<p>만약 새로운 메소드가 추가된다면 모든 클래스 hierarchy에 있는 클래스에 메소드를 추가해야 한다.</p>
<h3 id="lecture-46-pattern-matching">Lecture 4.6 - Pattern Matching</h3>
<p>good fit for the problem of decomposition</p>
<h4 id="case-classes">Case Classes</h4>
<p>case classes 의 정의는 일반 class 정의와 비슷하다. 앞에 case를 붙이는 것 빼고</p>
<pre><code class="scala">trait Expr
case class Number(n: Int) extends Expr
case class Sum(e1: Expr, e2: Expr) extends Expr
</code></pre>

<p>위와 같이 하면 자동적으로 object와 apply methods가 생성된다.</p>
<pre><code class="scala">object Number {
  def apply(n: Int) = new Number(n)
}
object Sum {
  def apply(e1: Expr, e2: Expr) = new Sum(e1, e2)
}
</code></pre>

<p>object로 만들어졌기 때문에 new Number(1) 대신 Number(1)로서 사용할 수 있다.</p>
<h4 id="pattern-matching">Pattern Matching</h4>
<p>클래스 구조에서 C와 Java의 switch 의 generalization이다.</p>
<pre><code class="scala">def eval(e: Expr): Int = e match {
  case Number(n) =&gt; n
  case Sum(e1, e2) =&gt; eval(e1) + eval(e2)
}
</code></pre>

<p>만약 일치하는 패턴이 없다면 MatchError가 발생한다.</p>
<p>Pattern이 될 수 있는 것은 아래와 같다.
- constructors, eg. Number, Sum
- variables, e.g. n, e1, e2
- wildcard patterns _,
- constants, e.g. 1, true.</p>
<p>참고로 아래와 같은 제약 사항이 있다.
variables는 반드시 소문자로 시작해야 하며
pattern안에 변수명은 한 번만 쓰여야 한다. 예로 Sum(x, x)는 안된다.
constants의 names은 대문자로 시작해야 한다.</p>
<h3 id="lecture-47-lists">Lecture 4.7 - Lists</h3>
<pre><code class="scala">val fruit = List(&quot;apples&quot;, &quot;oranges&quot;, &quot;pears&quot;)
val nums = List(1,2,3,4)
val diag3 = List(List(1, 0, 0))
val empty = List()
</code></pre>

<p>List와 Array는 중요한 차이가 있다.
- List는 immutable 하다. -&gt; element of a list cannot be changed
- List는 recursive 하다. 반면 Array는 flat하다.</p>
<h4 id="the-list-type">The List Type</h4>
<p>array같이 lists는 homogeneous하다. (list의 모든 element가 동일한 타입이어야 한다)</p>
<pre><code class="scala">val fruit: List[String] = List(&quot;apples&quot;, &quot;oranges&quot;, &quot;pears&quot;)
val nums: List[Int] = List(1,2,3,4)
val diag3: List[List[Int]] = List(List(1, 0, 0))
val empty: List[Nothing] = List()
</code></pre>

<h4 id="constructors-of-lists">Constructors of Lists</h4>
<ul>
<li>empty list Nil</li>
<li>operation <code>::</code> (pronounced cons)<ul>
<li><code>x :: xs</code> 는 첫 번째 element가 x이고 그 뒤로 xs가 오는 새로운 list를 생성한다.</li>
</ul>
</li>
</ul>
<pre><code class="scala">fruit = &quot;apples&quot; :: (&quot;oranged&quot; :: (&quot;pears&quot; :: Nil))
nums = 1 :: (2 :: (3 :: (4 :: Nil)))
empty = Nil
</code></pre>

<p>A :: B :: C는 A :: (B :: C)로 인터프리트 된다.</p>
<pre><code class="scala">val nums = 1 :: 2 :: 3 :: 4 :: Nil

// 위 표현과 같은 의미로 다르게 쓸 수 있다.
Nil.::(4).::(3).::(2).::(1)
</code></pre>

<h4 id="operations-on-lists">Operations on Lists</h4>
<p>head
tail
isEmpty</p>
<h4 id="list-patterns">List Patterns</h4>
<p>Nil                   -&gt; The Nil constant
p :: ps               -&gt; head가 p이고 나머지가 ps에 매칭
List(p1, ... , pn)    -&gt; same as p1 :: ... :: pn :: Nil</p>
<ul>
<li>examples</li>
</ul>
<p>1 :: 2 :: xs    1과 2로 시작하는 list
x :: Nil        length가 1인 List
List (x)        x :: Nil과 동일
List()          empty list, Nil과 동일
List(2 :: xs)   2로 시작하는 리스트를 포함하는 리스트</p>
<h4 id="sorting-lists">Sorting Lists</h4>
<ul>
<li>Insertion Sort
List(7,3,9,2)가 있을 때 tail List인 List(3,9,2)를 sort해서 (2, 3, 9)를 얻고 7을 적절한 위치에 배치해 (2, 3, 7, 9)를 만든다.</li>
</ul>
<pre><code class="scala">def isort(xs: List[Int]): List[Int] = xs match {
  case List() =&gt; List()
  case y :: ys =&gt; insert(y, isort(ys))
}
</code></pre>

<h2 id="week5">Week5</h2>
<h3 id="lecture-51-more-functions-on-lists">Lecture 5.1 - More Functions on Lists</h3>
<h4 id="list-methods1">List Methods(1)</h4>
<p>xs.length
xs.last    -&gt; xs가 empty라면 Error
xs.init    -&gt; last를 제외한 나머지 리스트. xs가 empty라면 Error
xs take n  -&gt; xs 리스트 내 맨 앞부터 n개를 취한 리스트. 또는 n이 xs 길이 보다 크다면 xs 자체를 리턴
xs drop n  -&gt; xs 리스트 내 맨 앞부터 n 개를 버린 뒤의 리스트
xs(n)</p>
<h4 id="list-methods1_1">List Methods(1)</h4>
<ul>
<li>
<p>Creating new Lists:
xs ++ ys           -&gt; xs 리스트 뒤에 ys를 합친 리스트
xs.reverse
xs updated (n, x)  -&gt; n번째 index에는 x를 넣고 나머지는 xs인 리스트</p>
</li>
<li>
<p>Finding elements:
xs indxOf x    -&gt; xs 리스트내 x와 같은 첫 번째 element의 index. 없다면 -1 리턴
xs contains x  -&gt; same as <code>xs indexOf x &gt;= 0</code></p>
</li>
</ul>
<h4 id="implementations">Implementations</h4>
<pre><code class="scala">def last[T](xs: List[T]): T = xs match {
  case List() =&gt; throw new Error(&quot;last of empty list&quot;)
  case List(x) =&gt; x
  case y :: ys =&gt; last(ys)
}
</code></pre>

<pre><code class="scala">def init[T](xs: List[T]): List[T] = xs match {
  case List() =&gt; throw new Error(&quot;init of empty list&quot;)
  case List(x) =&gt; List()
  case y :: ys =&gt; y :: init(ys)
}
</code></pre>

<pre><code class="scala">def concat[T](xs: List[T],  ys: List[T]): = xs match {
  case List() =&gt; ys
  case z :: zs =&gt; z :: concat(zs, ys)
}
</code></pre>

<pre><code class="scala">def reverse[T](xs: List[T]): List[T] = xs match {
  case List() =&gt; List()
  case y :: ys =&gt; reverse(ys) ++ List(y) // ++ 는 concatenation이다.
}
</code></pre>

<p>위의 reverse함수는 concat할때 n, reverse할 때 n
n * n 의 복잡도를 갖는다.</p>
<pre><code class="scala">def removeAt(n: Int, xs: List[Int]) = (xs take n) ::: (xs drop n + 1)
</code></pre>

<h3 id="lecture-52-pairs-and-tuples">Lecture 5.2 - Pairs and Tuples</h3>
<p>insertion sort보다 좋은 알고리즘인 merge sort를 구현해보자.</p>
<p>만약 리스트가 비어있거나 한 개의 엘리먼트가 있다면 이미 소팅된 것이다.
그렇지 않다면
- 리스트를 절반으로 나누어 두 개의 서브 리스트를 만든다.
- 서브 리스트를 sort 한다
- 두 개의 sort된 sub lists를 합친다.</p>
<h4 id="splitat-function">SplitAt Function</h4>
<p>returns two sublists</p>
<ul>
<li>주어진 index로 부터의 앞 요소들</li>
<li>주어진 index로 부터의 뒤 요소들
lists가 <code>pair</code>로 리턴된다.</li>
</ul>
<h4 id="detour-pair-and-tuples">Detour: Pair and Tuples</h4>
<p>x,y pair는 <code>(x, y)</code> 로 표현한다.</p>
<pre><code class="scala">val pair = (&quot;answer&quot;, 42)

val (label, value) = pair
</code></pre>

<h4 id="the-tuple-class">The Tuple class</h4>
<p>모든 Tuple n 클래스는 다음과 같은 패턴으로 모델 된다.</p>
<pre><code class="scala">case class Tuple2[T1, T2](_1: +T1, _2: +T2) {
  override def toString = &quot;(&quot; + _1 + &quot;,&quot; + _2 + &quot;)&quot;
}
</code></pre>

<p>아래는 pattern binding
<code>val (label, value) = pair</code></p>
<p>대신 아래와 같이 쓸 수 있다.</p>
<pre><code class="scala">val label = pair._1
val value = pair._2
</code></pre>

<p>하지만 패턴 매칭 폼이 일반적으로 선호된다.</p>
<pre><code class="scala">def msort(xs: List[Int]): List[Int] = {
  val n = xs.length / 2
  if (n == 0) xs
  else {
    def merge(xs: List[Int], ys: List[Int]): List[Int] = (xs, ys) match {
      case (Nil, ys) =&gt; ys
      case (xs, Nil) =&gt; xs
      case (x :: xs1, y :: ys1) =&gt;
        if (x &lt; y) x :: merge (xs1, ys)
        else y :: merge(xs, ys1)
    }
    val (fst, snd) = xs splitAt n
    merge(msort(fst), msort(snd))
  }
}
val nums = List(2, -4, 5, 7, 1)
msort(nums)
</code></pre>

<h3 id="lecture-53-implicit-parameters">Lecture 5.3 - Implicit Parameters</h3>
<h4 id="making-sort-more-general">Making Sort more General</h4>
<p>msort를 모든 타입에 대해서 구현해보자</p>
<pre><code class="scala">def msort[T](xs: List[T]): List[T] = ???
</code></pre>

<p>이전에 구현했던 코드를 그대로 바꾼다고 하면 동작하지 않는다.
<code>&lt;</code> 가 모든 타입 T에서 정의되지 않았기 때문이다.
=&gt; 비교 함수가 필요하다.</p>
<h4 id="parametrization-with-ordered">Parametrization with Ordered</h4>
<p>Ordering을 위한 standard library가 있다.
<code>scala.math.Ordering[T]</code>
이를 이용하면 아래와 같이 가능하다.</p>
<pre><code class="scala">import math.Ordering
def msort[T](xs: List[T])(ord: Ordering[T]): List[T] = {
  val n = xs.length / 2
  if (n == 0) xs
  else {
    def merge(xs: List[T], ys: List[T]): List[T] = (xs, ys) match {
      case (Nil, ys) =&gt; ys
      case (xs, Nil) =&gt; xs
      case (x :: xs1, y :: ys1) =&gt;
        if (ord.lt(x, y)) x :: merge (xs1, ys)
        else y :: merge(xs, ys1)
    }
    val (fst, snd) = xs splitAt n
    merge(msort(fst)(ord), msort(snd)(ord))
  }
}

val nums = List(2, -4, 5, 7, 1)
// x와 y에 타입을 지정 안해도 scala compiler가 Int를 인지 한다.
msort(nums)(Ordering.Int)

val fruits = List(&quot;apple&quot;, &quot;pineapple&quot;, &quot;orange&quot;, &quot;banana&quot;)
// compareTo는 JAVA String 메서드이다.
// first string 이 second string 보다 작으면 -1 같으면 0 크면 1을 리턴한다.
msort(fruits)(Ordering.String)
</code></pre>

<h4 id="aside-implicit-parameters">Aside: Implicit Parameters</h4>
<p>passing lt or ord values는 거추장스럽다.
implicit paramter로 이를 피할 수 있다.</p>
<pre><code class="scala">import math.Ordering
def msort[T](xs: List[T])(implicit ord: Ordering[T]): List[T] = {
  val n = xs.length / 2
  if (n == 0) xs
  else {
    def merge(xs: List[T], ys: List[T]): List[T] = (xs, ys) match {
      case (Nil, ys) =&gt; ys
      case (xs, Nil) =&gt; xs
      case (x :: xs1, y :: ys1) =&gt;
        if (ord.lt(x, y)) x :: merge (xs1, ys)
        else y :: merge(xs, ys1)
    }
    val (fst, snd) = xs splitAt n
    merge(msort(fst), msort(snd))
  }
}

val nums = List(2, -4, 5, 7, 1)
// x와 y에 타입을 지정 안해도 scala compiler가 Int를 인지 한다.
msort(nums)

val fruits = List(&quot;apple&quot;, &quot;pineapple&quot;, &quot;orange&quot;, &quot;banana&quot;)
// compareTo는 JAVA String 메서드이다.
// first string 이 second string 보다 작으면 -1 같으면 0 크면 1을 리턴한다.
msort(fruits)
</code></pre>

<p>위와 같이 implicit을 선언해주면 타입을 안넘겨줘도 컴파일러가 해결해준다.</p>
<h4 id="rules-for-implicit-parameters">Rules for Implicit Parameters</h4>
<p>function이 type T에 대한 implicit arguments를 받는 다면 아래와 같이 implicit definition을 찾는다.
- is marked implicit
- has a type compatible with T
- is visible at the point of the function call, or is defined in a companion object associated with T</p>
<p>만약 이 중에 가장 구체적인 하나의 정의가 있다면 이를 적용한다.
그 외의 모든 경우는 에러를 발생시킨다.</p>
<h3 id="lecture-54-higher-order-list-functions">Lecture 5.4 - Higher-Order List Functions</h3>
<p>lists의 모든 함수들은 first order이다.
그 말은 functions들이 primitive type의 lists를 arguments로 받고 그들을 결과로서 리턴한다는 것이다.</p>
<p>여기에서는 다른 함수를 arguments로 받는 higher-order list functions를 구현해본다.</p>
<h4 id="map">Map</h4>
<p>map의 실제 구현은 아래 보다 복잡하다.
실제 코드는 tail-recusrive 하고, 모든 collection에 대해 적용 가능하기 때문이다.</p>
<pre><code class="scala">abstract class List[T] {
  def map[U](f: T =&gt; U): List[U] = this match {
    case Nil =&gt; this
    case x :: xs =&gt; f(x) :: xs.map(f)
  }
}
</code></pre>

<p>이를 이용한 함수는 아래와 같다.</p>
<pre><code class="scala">def scalaList(xs: List[Double], factor: Double) =
  xs map (x =&gt; x * factor)
</code></pre>

<h4 id="filtering">Filtering</h4>
<p>또 다른 common operation on lists에는 주어진 조건에 맞는 elements만 select하는 filtering이 있다.</p>
<pre><code class="scala">def filter(p: T =&gt; Boolean): List[T] = this match {
  case Nil =&gt; this
  case x :: xs =&gt; if(p(x)) x :: xs.filter(p) else xs.filter(p)
}
</code></pre>

<pre><code class="scala">// filter 사용 안 한 버전
def posElems(xs: List[Int]): List[Int] = xs match {
  case Nil =&gt; xs
  case y :: ys =&gt; if (y &gt; 0) y :: posElems(ys) else posElems(ys)
}

// filter 사용 버전
def posElems(xs: List[Int]): List[Int] =
  xs filter (x =&gt; x &gt; 0)
</code></pre>

<h4 id="variations-of-filter">Variations of Filter</h4>
<pre><code class="scala">xs filterNot p // same as filter(x =&gt; !p(x))

xs partition p // same as (xs filter p, xs filterNot p)

xs takeWhile p //  p를 만족하는 모든 elements들의 longest prefix of list xs

xs dropWhile p // 첫 요소 부터 p를 만족하는 elements를 모두 제외하고 불만족 된 element 부터 마지막까지의 list

xs span p // same as (xs takeWhile p, xs dropWhile p)
</code></pre>

<pre><code class="scala">val nums = List(2, -4, 5, 7, 1)
val fruits = List(&quot;apple&quot;, &quot;pineapple&quot;, &quot;orange&quot;, &quot;banana&quot;)

nums filter (x =&gt; x &gt; 0)
nums filterNot (x =&gt; x &gt; 0)
nums partition (x =&gt; x &gt; 0)

nums takeWhile (x =&gt; x &gt; 0) // 2
nums dropWhile (x =&gt; x &gt; 0) // -4, 5, 7, 1
nums span (x =&gt; x &gt; 0) // (List(2), List(-4, 5, 7, 1))

val data = List(&quot;a&quot;, &quot;a&quot;, &quot;a&quot; , &quot;b&quot;, &quot;c&quot; , &quot;c&quot;, &quot;a&quot;)
def pack[T](xs: List[T]): List[List[T]] = xs match {
  case Nil =&gt; Nil
  case x :: xs1 =&gt;
    val (first, rest) = xs span(y =&gt; y == x)
    first :: pack(rest)
}
pack(data) // List(List(a,a,a), List(b)...

def encode[T](xs: List[T]): List[(T, Int)] =
  pack(xs) map (ys =&gt; (ys.head, ys.length))

encode(data) // List((a, 3), (b, 1), (c, 2), (a, 1))
</code></pre>

<h3 id="lecture-55-reduction-of-lists">Lecture 5.5 - Reduction of Lists</h3>
<p>이번에는 저번에 이어 hof를 배우는데 fold or reduce combiators라 불리는 함수들을 배울 것이다.</p>
<h4 id="reduceleft">ReduceLeft</h4>
<pre><code class="scala">def sum(xs: List[Int]): Int = xs match {
  case Nil =&gt; 0
  case y :: ys =&gt; y + sum(ys)
}
</code></pre>

<p>위 와 같은 메서드는 redceLeft로 abstract 가능하다.
reduceLeft는 given binary operator를 list의 adjacent elements 사이에 insert하는 것이다.</p>
<blockquote>
<p>List(x1, ..., xn) reduceLeft op = (... (x1 op x2) op ... ) op xn</p>
</blockquote>
<p>reduceLeft를 사용하면 아래와 같이 가능하다</p>
<pre><code class="scala">def sum(xs: List[Int]) = (0 :: xs) reduceLeft ((x, y) =&gt; x + y)
def product(xs: List[Int]) = (1 :: xs) reduceLeft ((x, y) =&gt; x * y)
</code></pre>

<h4 id="a-shorter-way-to-write-functions">A Shorter Way To Write Functions</h4>
<p>((x, y) =&gt; x * y) 대신 아래와 같이 쓸 수 있다.</p>
<pre><code class="scala">(_ * _)
</code></pre>

<p>모든 <code>_</code> 는 new parameter를 나타낸다. 왼쪽부터 오른쪽으로
이 parameter는 next outer pair of parentheses까지 유효하다.</p>
<pre><code class="scala">def sum(xs: List[Int]) = (0 :: xs) reduceLeft (_ + _)
def product(xs: List[Int]) = (1 :: xs) reduceLeft (_ * _)
</code></pre>

<h4 id="foldleft">FoldLeft</h4>
<p>reduceLeft의 더 general 한 function이 있는데 이를 foldLeft라고 한다.</p>
<p>reduceLeft와 비슷하지만 additional parameter로서 <code>accumulator</code> z 를 받는다.
empty list일 경우 z를 리턴한다.</p>
<pre><code class="scala">def sum(xs: List[Int]) = (xs foldLeft 0) (_ + _)
def product(xs: List[Int]) = (xs foldLeft 1) (_ * _)
</code></pre>

<h4 id="implementations-of-reduceleft-and-foldleft">Implementations of ReduceLeft and FoldLeft</h4>
<pre><code class="scala">abstract class List[T] { ...
  def reduceLeft(op: (T, T) =&gt; T): T = this match {
    case Nil =&gt; throw new Error(&quot;Nil.reduceLeft&quot;)
    case x :: xs =&gt; (xs foldLeft x)(op)
  }
  def foldLeft[U](z: U)(op: (U, T) =&gt; U): U = this match {
    case Nil =&gt; z
    case x :: xs =&gt; (xs foldLeft op(z, x))(op)
  }
}
</code></pre>

<p><img alt="" src="../scala%20implementatios%20of%20reduceLeft%20and%20foldLeft.jpg" /></p>
<h3 id="foldright-and-reduceright">FoldRight and ReduceRight</h3>
<p>foldLeft와 reduceLeft는 unfold on tress that lean to the left 를 한다.</p>
<p>반대로 FoldRight와 ReduceRight는 produce trees which lean to the right 한다.</p>
<p>List(x1, ..., x{n-1}, xn) reduceRight op = x1 op ( ... (x{n-1} op xn) ... )
(List(x1, ..., xn) foldRight acc)(op)    = x1 op ( ... (xn op acc) ... )</p>
<p><img alt="" src="../scala%20implementatios%20of%20reduceRight%20and%20foldRight.jpg" /></p>
<pre><code class="scala">abstract class List[T] { ...
  def reduceRight(op: (T, T) =&gt; T): T = this match {
    case Nil =&gt; throw new Error(&quot;Nil.reduceLeft&quot;)
    case x :: xs =&gt; op(x, xs.reduceRight(op))
  }
  def foldRight[U](z: U)(op: (U, T) =&gt; U): U = this match {
    case Nil =&gt; z
    case x :: xs =&gt; op(x, (xs foldRight z)(op))
  }
}
</code></pre>

<h4 id="difference-between-foldleft-and-foldright">Difference between FoldLeft and FoldRight</h4>
<p>produce different tree
Left leaning trees, Right leaning trees</p>
<p>둘 이 동일한 결과를 만들어 낼 수도 있지만(효율성에선 차이가 있을 수 있다) 때때로는 한 가지만 적용 가능하다.</p>
<pre><code class="scala">def concat[T](xs: List[T], ys: List[T]): List[T] =
  (xs foldRight ys) (_ :: _)
</code></pre>

<p>위의 함수에서 foldLeft는 안된다. 왜냐?!
<code>::</code> 연산자에 paramter 타입 T가 올 수 없기 때문이다. List만 전달해야 한다.
(그림을 그려보면 foldLeft의 오른쪽엔 T값들이 온다.)</p>
<h3 id="lecture-56-reasoning-about-concat">Lecture 5.6 - Reasoning About Concat</h3>
<h3 id="lecture-57-a-larger-equational-proof-on-lists">Lecture 5.7 - A Larger Equational Proof on Lists</h3>
<h2 id="week6">Week6</h2>
<h3 id="lecture-61-other-collections">Lecture 6.1 - Other Collections</h3>
<p>이전에 봤듯이 list는 linear이다.
첫 번째 element에 접근하는 것이 마지막 element를 접근하는 것보다 빠르다.</p>
<p>스칼라에는 sequence를 구현한 또 다른 <code>Vector</code>가 있다.
이는 list보다 보다 밸런스된 access pattern을 갖는다.</p>
<p><img alt="" src="../scala%20vectors.jpg" /></p>
<p>여러 depth의 Vector의 공식은</p>
<blockquote>
<p>log<sub>32</sub>n (n은 vector size이다.)</p>
</blockquote>
<p>이 의미는 vector의 크기가 커져도 access 속도가 느리게 증가한다는 것이다.
그렇기 때문에 decent random access에서 list 보다 vector가 빠르다.</p>
<p>또한 vector는 bulk operation에 좋다.
- sequence를 traverse하는 것
- map 함수 적용
- fold 함수 적용</p>
<p>Vector가 더 좋다면 list는 왜 써야 하나?
head만 얻을 경우 혹은 tail만 list가 상수 시간으로서 더 유리하다.
이처럼 access pattern이 recursive structures일 땐 list가 더 유리하다.
만약 access pattern이 bulk operation이라면 map, fold, filter 처럼, vector가 더 유리하다.</p>
<p>다행히도 Vector와 List간의 전환은 쉽다</p>
<pre><code class="scala">val nums = Vector(1, 2, 3, -88)
val people = Vector(&quot;Vector&quot;, &quot;James&quot;, &quot;Peter&quot;)
</code></pre>

<p>또한 list와 동일한 operations을 지원한다. <code>::</code>을 제외하고
대신 아래와 같은 것들이 있다.</p>
<pre><code class="scala">x +: xs // Create a new vector with leading element x, followed by all elements of xs

xs :+ x // Create a new vector with trailing element x, preceded by all elements of xs
</code></pre>

<p>(<code>:</code>은 항상 sequence를 가리킨다.)</p>
<p>vector에 add는 어떻게 할까?
아래 그림과 같이 맨 아래쪽에 위치한 빨간색의 Vector를 추가한다고 했을 때
위쪽 레벨로 올라가면서 이전과 동일한 element들을 가리키면서 하나는 새로 만든 element를 가리키는 새로운 벡터를 만들면서 root 레벨까지 올라간다.
그렇기 때문에 복잡도는 log<sub>32</sub>n 이다. (Object를 생성하는데 걸리는 시간)
<img alt="" src="../scala%20vectors.jpg" /></p>
<p>list와 vector의 base class는 Seq이다.
그리고 Seq은 Iterable의 subclass이다.</p>
<p>Arrays와 Strings는 Seq와 동일한 operations를 제공한다.
그렇기에 필요할때 명시적으로 변경할 수 있다.</p>
<pre><code class="scala">val xs: Array[Int] = Array(1,2,3)
xs map (x =&gt; 2 * x)

val ys: String = &quot;Hello world!&quot;
ys filter (_.isUpper)
</code></pre>

<p>또다른 sequence type으로 <code>range</code>가 있다.
sequence of evenly spaced integers를 표현한다.</p>
<p>3개의 operators가 있다.
- to (inclusive)
- until (exclusive)
- by (to determine step value)</p>
<pre><code class="scala">val r: Range = 1 until 5 // 1,2,3,4
val s: Range = 1 to 5    // 1,2,3,4,5
1 to 10 by 3             // 1,4,7,10
6 to 1 by -2             // 6,4,2
</code></pre>

<p>Ranges는 lower bound, upper bound, step value 3개의 필드를 갖는 single Object로 표현할 수 있다.</p>
<p>Sequence는 아래와 같은 operations도 제공한다.</p>
<pre><code class="scala">xs exists p
xs forall p   // xs의 모든 요소에 p(x)가 true라면 true 그 외는 false
xs zip ys     // xs와 ys의 요소들을 pair로 만든 새로운 sequence를 만든다. 예로 List(1,2) List('a', 'b')가 있다면 List((1, 'a'), (2, 'b'))가 된다.
xs.unzip
xs.flatMap f  // f를 xs의 모든 element에 적용하고 results를 concatenate한다.
xs.sum
xs.product
xs.max
xs.min
</code></pre>

<pre><code class="scala">val s = &quot;Hello World&quot;
s filter (c =&gt; c.isUpper) // HW
s exists (c =&gt; c.isUpper) // true
s forall (c =&gt; c.isUpper) // false

val pairs = List(1,2,3) zip s // List((1, H), (2, e), (3, l))
pairs.unzip                   // (List(1,2,3), List(H,e,l))

s flatMap (c =&gt; List('.', c)) // .H.e.l.l.o. .W.o.r.l.d

xs.sum // 50
xs.max // 44


def combinations(m: Int, n: Int) =
  (1 to m) flatMap (x =&gt; (1 to n) map (y =&gt; (x, y)))

combinations(4,4)

def scalaProduct(xs: Vector[Double], ys: Vector[Double]): Double =
  (xs zip ys).map(xy =&gt; xy._1 * xy._2).sum

// 위 식은 pattern matching function value로 아래처럼 쓸 수 있다.
def scalaProductUsingPattern(xs: Vector[Double], ys: Vector[Double]): Double =
  (xs zip ys).map{ case (x, y) =&gt; x * y}.sum

def isPrime(n: Int): Boolean = (2 until n) forall (d =&gt; n % d != 0)
</code></pre>

<h3 id="lecture-62-combinatorial-search-and-for-expressions">Lecture 6.2 - Combinatorial Search and For-Expressions</h3>
<h3 id="lecture-63-combinatorial-search-example">Lecture 6.3 - Combinatorial Search Example</h3>
<h3 id="lecture-64-maps">Lecture 6.4 - Maps</h3>
<h3 id="lecture-65-putting-the-pieces-together">Lecture 6.5 - Putting the Pieces Together</h3>
<h3 id="conclusion">Conclusion</h3>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../fpd-in-scala/" class="btn btn-neutral float-right" title="Coursera/fpd-in-scala">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../.." class="btn btn-neutral" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../.." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../fpd-in-scala/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
