{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"scala/","text":"Welcome","title":"Welcome"},{"location":"scala/#welcome","text":"","title":"Welcome"},{"location":"scala/Coursera/","text":"dd","title":"Index"},{"location":"scala/Coursera/fpd-in-scala/","text":"sss","title":"Index"},{"location":"scala/Coursera/fpd-in-scala/week1_1-RecapFunctionsAndPatternMatching/","text":"Week1-1: Recap: Functions and Pattern Matching Pattern Matching\uc758 \uc608 def show(json: JSON): String = json match { case JSeq(elems) => \"[\" + (elems map show mkString \", \") + \"]\" case JObj(bindings) => val assocs = bindings map { case (key, value) => \"\\\"\" + key + \"\\\": \" + show(value) } \"{\" + (assocs mkString \", \") + \"}\" case JNum(num) => num.toString case JStr(str) => \"\\\"\" + str + \"\\\"\" case JBool(b) => b.toString case JNull => \"null\" } scala\uc5d0\uc11c \ubaa8\ub4e0 concrete type\uc740 class or trait \uc774\ub2e4. function\ub3c4 \uc608\uc678\uac00 \uc544\ub2c8\ub2e4. JBinding => String \uc740 scala.Function1[JBinding, String] \uc758 \ucd95\uc57d\ud615\uc774\ub2e4. scala.Function1\uc740 trait\uc774\uace0 JBinding\uacfc String\uc740 type arguments\uc774\ub2e4. Partial Function another subtype of function, special type\uc774\ub2e4. function\uacfc \ub3d9\uc77c\ud558\uac8c apply\ub97c \uac00\uc9c0\uba74\uc11c isDefinedAt \uc744 \ucd94\uac00\ub85c \uac16\ub294\ub2e4. trait PartialFunction[-A, +R] extends Function1[-A, +R] { def apply(x: A): R def isDefinedAt(x: A): Boolean } val f1: String => String = { case \"ping\" => \"pong\"} f1(\"ping\") // pong f1(\"abc\") // MatchError!!! val f: PartialFunction[String, String] = { case \"ping\" => \"pong\" } f.isDefinedAt(\"ping\") // true f.isDefinedAt(\"pong\") // false \ub9cc\uc57d PartialFunction type\uc774 \uae30\ub300\ub41c\ub2e4\uba74 Scala Compiler\ub294 \uc544\ub798\uc640 \uac19\uc774 \ud655\uc7a5\ud55c\ub2e4. { case \"ping\" => \"pong\" } as follows: new PartialFunction[String, String] { def apply(x: String) = x match { case \u201dping\u201d => \u201dpong\u201d } def isDefinedAt(x: String) = x match { case \u201dping\u201d => true case _ => false } } Excercise1 val f: PartialFunction[List[Int], String] = { case Nil => \u201done\u201d case x :: y :: rest => \u201dtwo\u201d } f.isDefinedAt(List(1, 2, 3)) // true val g: PartialFunction[List[Int], String] = { case Nil => \u201done\u201d case x :: rest => rest match { case Nil => \u201dtwo\u201d } } g.isDefinedAt(List(1,2,3)) // ture g(List(1,2,3)) // Match Error!!! \uc704\uc5d0\uc11c \ubcf4\ub4ef\uc774 isDefinedAt \uc740 outmost matching block\ub9cc \uac80\uc99d\ud574\uc900\ub2e4. \uadf8\ub807\uae30 \ub54c\ubb38\uc5d0 g\uc5d0\uc11c\ub294 true\uac00 \ub9ac\ud134 \ub418\ub294 \uac83\uc774\ub2e4. \uc2e4\uc81c\ub85c \uc0ac\uc6a9\uc744 \ud574\ubcf4\uba74 case Nil \ubc16\uc5d0 case\uac00 \uc5c6\uae30 \ub54c\ubb38\uc5d0 \uc5d0\ub7ec\uac00 \ubc1c\uc0dd\ud55c\ub2e4.","title":"Week1-1: Recap: Functions and Pattern Matching"},{"location":"scala/Coursera/fpd-in-scala/week1_1-RecapFunctionsAndPatternMatching/#week1-1-recap-functions-and-pattern-matching","text":"Pattern Matching\uc758 \uc608 def show(json: JSON): String = json match { case JSeq(elems) => \"[\" + (elems map show mkString \", \") + \"]\" case JObj(bindings) => val assocs = bindings map { case (key, value) => \"\\\"\" + key + \"\\\": \" + show(value) } \"{\" + (assocs mkString \", \") + \"}\" case JNum(num) => num.toString case JStr(str) => \"\\\"\" + str + \"\\\"\" case JBool(b) => b.toString case JNull => \"null\" } scala\uc5d0\uc11c \ubaa8\ub4e0 concrete type\uc740 class or trait \uc774\ub2e4. function\ub3c4 \uc608\uc678\uac00 \uc544\ub2c8\ub2e4. JBinding => String \uc740 scala.Function1[JBinding, String] \uc758 \ucd95\uc57d\ud615\uc774\ub2e4. scala.Function1\uc740 trait\uc774\uace0 JBinding\uacfc String\uc740 type arguments\uc774\ub2e4.","title":"Week1-1: Recap: Functions and Pattern Matching"},{"location":"scala/Coursera/fpd-in-scala/week1_1-RecapFunctionsAndPatternMatching/#partial-function","text":"another subtype of function, special type\uc774\ub2e4. function\uacfc \ub3d9\uc77c\ud558\uac8c apply\ub97c \uac00\uc9c0\uba74\uc11c isDefinedAt \uc744 \ucd94\uac00\ub85c \uac16\ub294\ub2e4. trait PartialFunction[-A, +R] extends Function1[-A, +R] { def apply(x: A): R def isDefinedAt(x: A): Boolean } val f1: String => String = { case \"ping\" => \"pong\"} f1(\"ping\") // pong f1(\"abc\") // MatchError!!! val f: PartialFunction[String, String] = { case \"ping\" => \"pong\" } f.isDefinedAt(\"ping\") // true f.isDefinedAt(\"pong\") // false \ub9cc\uc57d PartialFunction type\uc774 \uae30\ub300\ub41c\ub2e4\uba74 Scala Compiler\ub294 \uc544\ub798\uc640 \uac19\uc774 \ud655\uc7a5\ud55c\ub2e4. { case \"ping\" => \"pong\" } as follows: new PartialFunction[String, String] { def apply(x: String) = x match { case \u201dping\u201d => \u201dpong\u201d } def isDefinedAt(x: String) = x match { case \u201dping\u201d => true case _ => false } }","title":"Partial Function"},{"location":"scala/Coursera/fpd-in-scala/week1_1-RecapFunctionsAndPatternMatching/#excercise1","text":"val f: PartialFunction[List[Int], String] = { case Nil => \u201done\u201d case x :: y :: rest => \u201dtwo\u201d } f.isDefinedAt(List(1, 2, 3)) // true val g: PartialFunction[List[Int], String] = { case Nil => \u201done\u201d case x :: rest => rest match { case Nil => \u201dtwo\u201d } } g.isDefinedAt(List(1,2,3)) // ture g(List(1,2,3)) // Match Error!!! \uc704\uc5d0\uc11c \ubcf4\ub4ef\uc774 isDefinedAt \uc740 outmost matching block\ub9cc \uac80\uc99d\ud574\uc900\ub2e4. \uadf8\ub807\uae30 \ub54c\ubb38\uc5d0 g\uc5d0\uc11c\ub294 true\uac00 \ub9ac\ud134 \ub418\ub294 \uac83\uc774\ub2e4. \uc2e4\uc81c\ub85c \uc0ac\uc6a9\uc744 \ud574\ubcf4\uba74 case Nil \ubc16\uc5d0 case\uac00 \uc5c6\uae30 \ub54c\ubb38\uc5d0 \uc5d0\ub7ec\uac00 \ubc1c\uc0dd\ud55c\ub2e4.","title":"Excercise1"},{"location":"scala/Coursera/fpd-in-scala/week1_2-RecapCollections/","text":"Week1-2: Recap: Collections All collection types share a common set of general methods. Core Methods: - map - flatMap - filter and also - foldLeft - foldRight abstract class List[+T] { def map[U](f: T => U): List[U] = this match { case x :: xs => f(x) :: xs.map(f) case Nil => Nil } } abstract class List[+T] { def flatMap[U](f: T => List[U]): List[U] = this match { case x :: xs => f(x) ++ xs.flatMap(f) case Nil => Nil } } map\uacfc\uc758 \ub2e4\ub978\uc810 1. map\uacfc \ub2ec\ub9ac f\uac00 List[U]\ub97c \ub9ac\ud134\ud55c\ub2e4. 2. ++\ub85c List\ub97c concat\ud55c\ub2e4.(List\ub07c\ub9ac\uc758 concat\uc774\ubbc0\ub85c)","title":"Week1-2: Recap: Collections"},{"location":"scala/Coursera/fpd-in-scala/week1_2-RecapCollections/#week1-2-recap-collections","text":"All collection types share a common set of general methods. Core Methods: - map - flatMap - filter and also - foldLeft - foldRight abstract class List[+T] { def map[U](f: T => U): List[U] = this match { case x :: xs => f(x) :: xs.map(f) case Nil => Nil } } abstract class List[+T] { def flatMap[U](f: T => List[U]): List[U] = this match { case x :: xs => f(x) ++ xs.flatMap(f) case Nil => Nil } } map\uacfc\uc758 \ub2e4\ub978\uc810 1. map\uacfc \ub2ec\ub9ac f\uac00 List[U]\ub97c \ub9ac\ud134\ud55c\ub2e4. 2. ++\ub85c List\ub97c concat\ud55c\ub2e4.(List\ub07c\ub9ac\uc758 concat\uc774\ubbc0\ub85c)","title":"Week1-2: Recap: Collections"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/","text":"Week3-1: Type-Directed Programming \uc9c0\uae08\uae4c\uc9c0 \ubd24\ub4ef\uc774 compiler\ub294 values\ub85c \ubd80\ud130 types\uc744 \uc720\ucd94\ud560 \uc218 \uc788\ub2e4. val x = 12 compiler\ub294 x\ub97c Int\ub85c \uc720\ucd94\ud55c\ub2e4. \uc65c\ub0d0\ud558\uba74 \uac12\uc774 12\uc774\ubbc0\ub85c \uc544\ub798\uc640 \uac19\uc774 \ubcf5\uc7a1\ud55c \ud45c\ud604\uc5d0\uc11c\ub3c4 \uc774\ub294 \uc801\uc6a9\ub41c\ub2e4. val y = x + 3 compiler\ub294 y \ub610\ud55c Int\ub85c \uc720\ucd94\ud55c\ub2e4. \uc774\ubc88\uc5d0\ub294 \ubc18\ub300\ub85c compiler\uac00 types\ub85c \ubd80\ud130 values\ub97c \uc720\ucd94\ud558\ub294 \uacfc\uc815\uc744 \ubcfc \uac83\uc774\ub2e4. \uc65c \uc774\uac83\uc774 \uc720\uc6a9\ud558\ub0d0? \ud655\uc2e4\ud55c \ud558\ub098\ub294 compiler\uac00 value\ub97c \ucc3e\uc544\uc11c \uc904 \uc218 \uc788\uae30 \ub54c\ubb38\uc774\ub2e4. \uc774\ubc88 \ub808\uc2a8\uc758 \ub098\uba38\uc9c0\ub294 \uc774\ub7f0 \uba54\uce74\ub2c8\uc998\uc758 motivation\uc744 \uc18c\uac1c\ud558\uace0 \ub2e4\uc74c \ubc88 \ub808\uc2a8\uc740 how to use it\uc744 \uc124\uba85\ud560 \uac83\uc774\ub2e4. Motivating Example parameter\ub85c List[Int]\ub97c \ubc1b\uc544\uc11c \uc815\ub82c\ud55c \uacb0\uacfc\ub97c List[Int]\ub85c \ub9ac\ud134\ud558\ub294 \ud568\uc218\ub97c \uc0dd\uac01\ud574\ubcf4\uc790. def sort(xs: List[Int]): List[Int] = { ... ... if (x < y) ... ... } \uc0c1\uc138 \ucf54\ub4dc\ub294 \uc5ec\uae30\uc5d0\uc11c \ud544\uc694\uac00 \uc5c6\uae30\uc5d0 \uc0dd\ub7b5\ud588\ub2e4. \uc704 \ucf54\ub4dc\ub294 Int\uc5d0 \ub300\ud574\uc11c\ub9cc \uc801\uc6a9 \uac00\ub2a5\ud558\ubbc0\ub85c general\ud558\uac8c \ubaa8\ub4e0 \ud0c0\uc785\uc5d0 \ub300\ud574\uc11c\ub3c4 \ub3d9\uc791\ud558\uac8c \ud558\uace0 \uc2f6\ub2e4. \uc774\uc5d0 \ub300\ud55c straightforward approach\ub294 polymorphic type\uc744 \uc0ac\uc6a9\ud558\ub294 \uac83\uc774\ub2e4. def sort[A](xs: List[A]): List[A] = ... \ud558\uc9c0\ub9cc \uc774\uac83\ub9cc\uc73c\ub85c\ub294 \ubd80\uc871\ud558\ub2e4. \uc65c\ub0d0\ud558\uba74 \uac01 type\ubcc4\ub85c compare\ub97c \ub2e4\ub974\uac8c \ud574\uc57c \ud558\uae30 \ub54c\ubb38\uc774\ub2e4. \uadf8\ub798\uc11c \uc774\ubc88\uc5d4 \uac01 compare \ud568\uc218\ub97c parameter\ub85c \ubc1b\ub3c4\ub85d \ud574\ubcf4\uc790. def sort[A](xs: List[A])(lessThan: (A, A) => Boolean): List[A] = { ... ... if (lessThan(x, y)) ... ... } \uadf8\ub807\uac8c \ub418\uba74 \uc544\ub798\uc640 \uac19\uc774 \uac00\ub2a5\ud558\ub2e4' val xs = List(-5, 6, 3, 2, 7) val strings = List(\"apple\", \"pear\", \"orange\", \"pineapple\") sort(xs)((x, y) => x < y) sort(strings)((s1, s2) => s1.compareTo(s2) < 0) Refactoring With Ordering scala\ub294 standard library \uc5d0\uc11c comparing \ud558\ub294 \ud568\uc218\ub97c \uae30\ubcf8\uc73c\ub85c \uc81c\uacf5\ud55c\ub2e4. package scala.math trait Ordering[A] { def compare(a1: A, a2: A): Int def lt(a1: A, a2: A): Boolean = compare(a1, a2) <= 0 ... } compare \ud568\uc218\ub294 2\uac1c\uc758 parameter\ub97c \ubc1b\uc544\uc11c \uccab \ubc88\uc9f8 \uac12\uc774 \ud074 \uacbd\uc6b0 \uc591\uc218, \uc791\uc744 \uacbd\uc6b0 \uc74c\uc218, \ub3d9\uc77c\ud55c \uacbd\uc6b0 0\uc744 \ub9ac\ud134\ud55c\ub2e4. \uc774\ub97c \uc0ac\uc6a9\ud558\uba74 \uc544\ub798\uc640 \uac19\uc774 \ubcc0\uacbd \uac00\ub2a5\ud558\ub2e4. def sort[A](xs: List[A])(ord: Ordering[A]): List[A] = { ... ... if (ord.lt(x, y)) ... ... } import scala.math.Ordering sort(xs)(Ordering.Int) sort(strings)(Ordering.String) \uc5ec\uae30\uc5d0\uc11c \uc0ac\uc6a9 \uc911\uc778 Int\uc640 String\uc740 types \uc774 \uc544\ub2c8\uace0 values \uc784\uc744 \uc54c\uc544\uc57c \ud55c\ub2e4. scala\uc5d0\uc11c\ub294 types\uacfc values\uc5d0 \ub3d9\uc77c\ud55c symbol\uc744 \uc0ac\uc6a9\ud558\ub294 \uac83\uc774 \uac00\ub2a5\ud558\ub2e4. object Ordering { val Int = new Ordering[Int] { def compare(x: Int, y: Int) = if (x > y) 1 else if (x < y) -1 else 0 } } Reducing Boilerplate \uc9c0\uae08\uae4c\uc9c0 \uc815\uc758\ud55c \uac83\uc744 \ub530\ub974\uba74 \uc798 \ub3d9\uc791\ud55c\ub2e4. \ud558\uc9c0\ub9cc \ubaa8\ub4e0 \uacbd\uc6b0\uc5d0 \ub300\ud574 boilerplate\uac00 \uc874\uc7ac\ud558\uac8c \ub41c\ub2e4. Int\ub97c \ube44\uad50\ud560 \ub54c\ub9c8\ub2e4 Ordering.Int \ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \uc0ac\uc6a9\ud574\uc57c \ud55c\ub2e4. sort(xs)(Ordering.Int) sort(ys)(Ordering.Int) sort(strings)(Ordering.String) Implicit Parameters implicit \uc744 \uba85\uc2dc\ud568\uc73c\ub85c\uc11c compiler\uac00 argument ord \ub97c support\ub97c \ud558\uac8c \ud560 \uc218 \uc788\ub2e4. def sort[A](xs: List[A])(implicit ord: Ordering[A]): List[A] = ... sort(xs) sort(ys) sort(strings) \uc704\uc640 \uac19\uc774 \ud558\uba74 \ucef4\ud30c\uc77c\ub7ec\uac00 value\uc5d0 \ub9de\ucdb0 type\uc744 \uacb0\uc815\ud55c\ub2e4. \ucef4\ud30c\uc77c\ub7ec\uac00 \uc218\ud589\ud558\ub294 \uacfc\uc815\uc744 \uc790\uc138\ud788 \uc0b4\ud3b4\ubcf4\uc790. sort(xs) xs \uac00 List[Int] \ud0c0\uc785\uc774\ubbc0\ub85c \ucef4\ud30c\uc77c\ub7ec\ub294 \uc704\uc758 \ucf54\ub4dc\ub97c \uc544\ub798\uc640 \uac19\uc774 \ubcc0\ud658\ud55c\ub2e4. sort[Int](xs) \uadf8\ub9ac\uace0 \ucef4\ud30c\uc77c\ub7ec\ub294 candidate definition\uc911 Ordering[Int] \ud0c0\uc785\uc5d0 \ub9de\ub294 \uac83\uc744 \ucc3e\ub294\ub2e4. \uc704\uc758 \ucf00\uc774\uc2a4\uc5d0\uc11c\ub294 Ordering.Int\uc640 only matching\ub418\uace0 \ucef4\ud30c\uc77c\ub7ec\ub294 method sort\ub85c \uc774\ub97c \uc804\ub2ec\ud55c\ub2e4. sort[Int](xs)(Ordering.Int) candidate values\uac00 \uc5b4\ub5bb\uac8c \uc815\uc758\ub3c4\uc5b4\uc788\ub294 \uc9c0\ub97c \uc0b4\ud3b4 \ubcf4\uae30 \uc804\uc5d0 implicit \ud0a4\uc6cc\ub4dc\uc5d0 \ub300\ud574 \uc790\uc138\ud788 \uc54c\uc544\ubcf4\uc790. method\ub294 \uc624\uc9c1 \ud558\ub098\uc758 implicit parameter list\ub97c \uac00\uc9c8 \uc218 \uc788\uc73c\uba70 \uc774\ub294 \ub9c8\uc9c0\ub9c9 paramter\uac00 \ub418\uc57c \ud55c\ub2e4. At call site, the arguments of the given clause are usually left out, although it is possible to explicitly pass them: // Argument inferred by the compiler sort(xs) // Explicit argument sort(xs)(Ordering.Int.reverse) Candidates for Implicit Parameters \ucef4\ud30c\uc77c\ub7ec\uac00 type T\uc5d0 \ub300\ud574 \uc5b4\ub5a4 candidate definition\ub97c \ucc3e\uc744\uae4c? \ucef4\ud30c\uc77c\ub7ec\ub294 \uc544\ub798 definition\uc744 \ucc3e\ub294\ub2e4. have type T, are marked implicit, are visible at the point of the function call, or are defined in a companion object associated with T. most specific\ud55c \uc815\uc758\ub97c \ucc3e\uac8c \ub418\uba74 \uadf8\uac83\uc744 \uc0ac\uc6a9\ud558\uace0 \uc5c6\ub2e4\uba74 error\ub97c report\ud55c\ub2e4. implicit Definition implicit definition\uc774\ub780 implicit \ud0a4\uc6cc\ub4dc\uc640 \ud568\uaed8 \uc815\uc758\ub41c \uac83\uc744 \ub9d0\ud55c\ub2e4. object Ordering { implicit val Int: Ordering[Int] = ... } \uc704\uc758 \ucf54\ub4dc\ub294 Int\ub77c\ub294 \uc774\ub984\uc744 \uac00\uc9c4 Ordering[Int] \ud0c0\uc785\uc758 implicit value\ub97c \uc815\uc758\ud55c \uac83\uc774\ub2e4. Any val, lazy val, def, or object definition can be marked implicit. \ub9c8\uc9c0\ub9c9\uc73c\ub85c implicit definitions\ub294 type parameters\uc640 implicit parameters\ub97c \uac00\uc9c8 \uc218 \uc788\ub2e4. implicit def orderingPair[A, B](implicit orderingA: Ordering[A], orderingB: Ordering[B] ): Ordering[(A, B)] = ... Implicit Search Scope type T\uc758 implicit value\ub97c \ucc3e\uae30 \uc704\ud574 \uccab \ubc88\uc9f8\ub85c visible(inherited, imported, or defined in an enclosing scope)\ud55c \ubaa8\ub4e0 implicit definitions\ub97c \ucc3e\ub294\ub2e4. \ub9cc\uc57d \ucef4\ud30c\uc77c\ub7ec\uac00 lexcial scope\uc5d0\uc11c implicit instance\uc640 \ub9e4\uce6d\ub418\ub294 type T\ub97c \ucc3e\uc9c0 \ubabb\ud558\uba74, T\uc640 \uad00\ub828\ub41c companion objects\uc5d0\uc11c \uc774\uc5b4\uc11c \ucc3e\ub294\ub2e4. (companion objects\uc640 types\ub294 other types\uc640 \uc5f0\uad00\uc788\ub2e4.) A companion object is an object that has the same name as a type. \uc608\ub85c object scala.math.Ordering is the companion of the type scala.math.Ordering. The types associated with a type T are: if T has parent types T\u2081 with T\u2082 ... with T\u2099, the union of the parts of T\u2081, ... T\u2099 as well as T itself, if T is a parameterized type S[T\u2081, T\u2082, ..., T\u2099], the union of the parts of S and T\u2081, ..., T\u2099, otherwise, just T itself. As an example, consider the following type hierarchy: trait Foo[A] trait Bar[A] extends Foo[A] trait Baz[A] extends Bar[A] trait X trait Y extends X \ub9cc\uc57d Bar[Y] \ud0c0\uc785\uc758 implicit value\uac00 \ud544\uc694\ud558\ub2e4\uba74 compiler\ub294 \uc544\ub798\uc640 \uac19\uc740 companion object\uc5d0\uc11c implicit definition\uc744 \ucc3e\uc744 \uac83\uc774\ub2e4. Bar, because it is a part of Bar[Y], Y, because it is a part of Bar[Y], Foo, because it is a parent type of Bar, and X, because it is a parent type of Y. However, the Baz companion object will not be visited. Implicit Search Process search process\ub294 no candidate found \ud639\uc740 \ub9e4\uce6d\ub418\ub294 \ucd5c\uc18c\ud55c \ud558\ub098\uc758 candidate\ub97c \uacb0\uacfc\ub97c \ub9cc\ub4e4\uc5b4 \ub0b8\ub2e4. \ub9cc\uc57d no no available implicit definition matching \uc774\ub77c\uba74 \uc5d0\ub7ec\uac00 repot \ub41c\ub2e4. scala> def f(implicit n: Int) = () scala> f ^ error: could not find implicit value for parameter n: Int \ubc18\ub300\ub85c \ub458 \uc774\uc0c1\uc758 implicit definition\uc774 eligibale \ud558\ub2e4\uba74 ambiguity\uac00 report \ub41c\ub2e4. scala> implicit val x: Int = 0 scala> implicit val y: Int = 1 scala> def f(implicit n: Int) = () scala> f ^ error: ambiguous implicit values: both value x of type => Int same type\uc5d0 \ub9e4\uce6d\ub418\ub294 several implicit definitions\uac00 \uc788\uc5b4\ub3c4 \ud558\ub098\ub97c \ud2b9\uc815 \ud560 \uc218 \uc788\ub2e4\uba74 \uad1c\ucc2e\ub2e4. A definition a: A is more specific than a definition b: B if: type A has more \u201cfixed\u201d parts, or, a is defined in a class or object which is a subclass of the class defining b. Let\u2019s see a few examples of priorities at work. Which implicit definition matches the Int implicit parameter when the following method f is called? implicit def universal[A]: A = ??? implicit def int: Int = ??? def f(implicit n: Int) = () f \uc704\uc758 \uacbd\uc6b0\uc5d0\uc11c universal\uc740 type paramter\ub97c \uc9c0\ub2c8\uace0 int\ub294 \uc544\ub2c8\uae30\uc5d0, int\uac00 more fixed parts\ub97c \uac16\uace0 \uc774\ub294 universal\ubcf4\ub2e4 \uba3c\uc800 \uace0\ub824\ub41c\ub2e4. \uadf8\ub807\uae30 \ub54c\ubb38\uc5d0 \ucef4\ud30c\uc77c\ub7ec\uac00 int\ub97c \uc120\ud0dd\ud568\uc5d0 \uc788\uc5b4 ambiguity\uac00 \uc5c6\ub2e4. \uc544\ub798\uc640 \uac19\uc774 \uc788\uc744 \ub54c implicit Int \ud30c\ub77c\ubbf8\ud130\ub97c \uac16\ub294 f method\ub294 \uc5b4\ub290 implicit definition\uc5d0 \ub9e4\uce58 \ub420\uae4c? trait A { implicit val x: Int = 0 } trait B extends A { implicit val y: Int = 1 def f(implicit n: Int) = () f } y\uac00 A\ub97c extend\ud558\ub294 trait\uc774\ubbc0\ub85c y\uac00 A\ubcf4\ub2e4 more specific \ud558\ub2e4. \uadf8\ub7ec\ubbc0\ub85c \ucef4\ud30c\uc77c\ub7ec\uac00 y\ub97c \uc120\ud0dd\ud558\ub294 \uac83\uc5d0 ambiguity\ub294 \uc5c6\ub2e4. Context Bounds Syntactic sugar allows the omission of the implicit parameter list: def printSorted[A: Ordering](as: List[A]): Unit = { println(sort(as)) } Type parameter A has one context bound: Ordering. This is equivalent to writing: def printSorted[A](as: List[A])(implicit ev1: Ordering[A]): Unit = { println(sort(as)) } More generally, a method definition such as: def f[A: U\u2081 ... : U\u2099](ps): R = ... Is expanded to: def f[A](ps)(implicit ev\u2081: U\u2081[A], ..., ev\u2099: U\u2099[A]): R = ... Implicit Query At any point in a program, one can query an implicit value of a given type by calling the implicitly operation: scala> implicitly[Ordering[Int]] res0: Ordering[Int] = scala.math.Ordering$Int$@73564ab0 Note that implicitly is not a special keyword, it is defined as a library operation: def implicitly[A](implicit value: A): A = value Summary In this lesson we have introduced the concept of type-directed programming, a language mechanism that infers values from types. There has to be a unique (most specific) implicit definition matching the queried type for it to be selected by the compiler. Implicit values are searched in the enclosing lexical scope (imports, parameters, inherited members) as well as in the implicit scope of the queried type. The implicit scope of type is made of implicit values defined in companion objects of types associated with the queried type.","title":"Week3-1: Type-Directed Programming"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#week3-1-type-directed-programming","text":"\uc9c0\uae08\uae4c\uc9c0 \ubd24\ub4ef\uc774 compiler\ub294 values\ub85c \ubd80\ud130 types\uc744 \uc720\ucd94\ud560 \uc218 \uc788\ub2e4. val x = 12 compiler\ub294 x\ub97c Int\ub85c \uc720\ucd94\ud55c\ub2e4. \uc65c\ub0d0\ud558\uba74 \uac12\uc774 12\uc774\ubbc0\ub85c \uc544\ub798\uc640 \uac19\uc774 \ubcf5\uc7a1\ud55c \ud45c\ud604\uc5d0\uc11c\ub3c4 \uc774\ub294 \uc801\uc6a9\ub41c\ub2e4. val y = x + 3 compiler\ub294 y \ub610\ud55c Int\ub85c \uc720\ucd94\ud55c\ub2e4. \uc774\ubc88\uc5d0\ub294 \ubc18\ub300\ub85c compiler\uac00 types\ub85c \ubd80\ud130 values\ub97c \uc720\ucd94\ud558\ub294 \uacfc\uc815\uc744 \ubcfc \uac83\uc774\ub2e4. \uc65c \uc774\uac83\uc774 \uc720\uc6a9\ud558\ub0d0? \ud655\uc2e4\ud55c \ud558\ub098\ub294 compiler\uac00 value\ub97c \ucc3e\uc544\uc11c \uc904 \uc218 \uc788\uae30 \ub54c\ubb38\uc774\ub2e4. \uc774\ubc88 \ub808\uc2a8\uc758 \ub098\uba38\uc9c0\ub294 \uc774\ub7f0 \uba54\uce74\ub2c8\uc998\uc758 motivation\uc744 \uc18c\uac1c\ud558\uace0 \ub2e4\uc74c \ubc88 \ub808\uc2a8\uc740 how to use it\uc744 \uc124\uba85\ud560 \uac83\uc774\ub2e4.","title":"Week3-1: Type-Directed Programming"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#motivating-example","text":"parameter\ub85c List[Int]\ub97c \ubc1b\uc544\uc11c \uc815\ub82c\ud55c \uacb0\uacfc\ub97c List[Int]\ub85c \ub9ac\ud134\ud558\ub294 \ud568\uc218\ub97c \uc0dd\uac01\ud574\ubcf4\uc790. def sort(xs: List[Int]): List[Int] = { ... ... if (x < y) ... ... } \uc0c1\uc138 \ucf54\ub4dc\ub294 \uc5ec\uae30\uc5d0\uc11c \ud544\uc694\uac00 \uc5c6\uae30\uc5d0 \uc0dd\ub7b5\ud588\ub2e4. \uc704 \ucf54\ub4dc\ub294 Int\uc5d0 \ub300\ud574\uc11c\ub9cc \uc801\uc6a9 \uac00\ub2a5\ud558\ubbc0\ub85c general\ud558\uac8c \ubaa8\ub4e0 \ud0c0\uc785\uc5d0 \ub300\ud574\uc11c\ub3c4 \ub3d9\uc791\ud558\uac8c \ud558\uace0 \uc2f6\ub2e4. \uc774\uc5d0 \ub300\ud55c straightforward approach\ub294 polymorphic type\uc744 \uc0ac\uc6a9\ud558\ub294 \uac83\uc774\ub2e4. def sort[A](xs: List[A]): List[A] = ... \ud558\uc9c0\ub9cc \uc774\uac83\ub9cc\uc73c\ub85c\ub294 \ubd80\uc871\ud558\ub2e4. \uc65c\ub0d0\ud558\uba74 \uac01 type\ubcc4\ub85c compare\ub97c \ub2e4\ub974\uac8c \ud574\uc57c \ud558\uae30 \ub54c\ubb38\uc774\ub2e4. \uadf8\ub798\uc11c \uc774\ubc88\uc5d4 \uac01 compare \ud568\uc218\ub97c parameter\ub85c \ubc1b\ub3c4\ub85d \ud574\ubcf4\uc790. def sort[A](xs: List[A])(lessThan: (A, A) => Boolean): List[A] = { ... ... if (lessThan(x, y)) ... ... } \uadf8\ub807\uac8c \ub418\uba74 \uc544\ub798\uc640 \uac19\uc774 \uac00\ub2a5\ud558\ub2e4' val xs = List(-5, 6, 3, 2, 7) val strings = List(\"apple\", \"pear\", \"orange\", \"pineapple\") sort(xs)((x, y) => x < y) sort(strings)((s1, s2) => s1.compareTo(s2) < 0)","title":"Motivating Example"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#refactoring-with-ordering","text":"scala\ub294 standard library \uc5d0\uc11c comparing \ud558\ub294 \ud568\uc218\ub97c \uae30\ubcf8\uc73c\ub85c \uc81c\uacf5\ud55c\ub2e4. package scala.math trait Ordering[A] { def compare(a1: A, a2: A): Int def lt(a1: A, a2: A): Boolean = compare(a1, a2) <= 0 ... } compare \ud568\uc218\ub294 2\uac1c\uc758 parameter\ub97c \ubc1b\uc544\uc11c \uccab \ubc88\uc9f8 \uac12\uc774 \ud074 \uacbd\uc6b0 \uc591\uc218, \uc791\uc744 \uacbd\uc6b0 \uc74c\uc218, \ub3d9\uc77c\ud55c \uacbd\uc6b0 0\uc744 \ub9ac\ud134\ud55c\ub2e4. \uc774\ub97c \uc0ac\uc6a9\ud558\uba74 \uc544\ub798\uc640 \uac19\uc774 \ubcc0\uacbd \uac00\ub2a5\ud558\ub2e4. def sort[A](xs: List[A])(ord: Ordering[A]): List[A] = { ... ... if (ord.lt(x, y)) ... ... } import scala.math.Ordering sort(xs)(Ordering.Int) sort(strings)(Ordering.String) \uc5ec\uae30\uc5d0\uc11c \uc0ac\uc6a9 \uc911\uc778 Int\uc640 String\uc740 types \uc774 \uc544\ub2c8\uace0 values \uc784\uc744 \uc54c\uc544\uc57c \ud55c\ub2e4. scala\uc5d0\uc11c\ub294 types\uacfc values\uc5d0 \ub3d9\uc77c\ud55c symbol\uc744 \uc0ac\uc6a9\ud558\ub294 \uac83\uc774 \uac00\ub2a5\ud558\ub2e4. object Ordering { val Int = new Ordering[Int] { def compare(x: Int, y: Int) = if (x > y) 1 else if (x < y) -1 else 0 } }","title":"Refactoring With Ordering"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#reducing-boilerplate","text":"\uc9c0\uae08\uae4c\uc9c0 \uc815\uc758\ud55c \uac83\uc744 \ub530\ub974\uba74 \uc798 \ub3d9\uc791\ud55c\ub2e4. \ud558\uc9c0\ub9cc \ubaa8\ub4e0 \uacbd\uc6b0\uc5d0 \ub300\ud574 boilerplate\uac00 \uc874\uc7ac\ud558\uac8c \ub41c\ub2e4. Int\ub97c \ube44\uad50\ud560 \ub54c\ub9c8\ub2e4 Ordering.Int \ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \uc0ac\uc6a9\ud574\uc57c \ud55c\ub2e4. sort(xs)(Ordering.Int) sort(ys)(Ordering.Int) sort(strings)(Ordering.String)","title":"Reducing Boilerplate"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#implicit-parameters","text":"implicit \uc744 \uba85\uc2dc\ud568\uc73c\ub85c\uc11c compiler\uac00 argument ord \ub97c support\ub97c \ud558\uac8c \ud560 \uc218 \uc788\ub2e4. def sort[A](xs: List[A])(implicit ord: Ordering[A]): List[A] = ... sort(xs) sort(ys) sort(strings) \uc704\uc640 \uac19\uc774 \ud558\uba74 \ucef4\ud30c\uc77c\ub7ec\uac00 value\uc5d0 \ub9de\ucdb0 type\uc744 \uacb0\uc815\ud55c\ub2e4. \ucef4\ud30c\uc77c\ub7ec\uac00 \uc218\ud589\ud558\ub294 \uacfc\uc815\uc744 \uc790\uc138\ud788 \uc0b4\ud3b4\ubcf4\uc790. sort(xs) xs \uac00 List[Int] \ud0c0\uc785\uc774\ubbc0\ub85c \ucef4\ud30c\uc77c\ub7ec\ub294 \uc704\uc758 \ucf54\ub4dc\ub97c \uc544\ub798\uc640 \uac19\uc774 \ubcc0\ud658\ud55c\ub2e4. sort[Int](xs) \uadf8\ub9ac\uace0 \ucef4\ud30c\uc77c\ub7ec\ub294 candidate definition\uc911 Ordering[Int] \ud0c0\uc785\uc5d0 \ub9de\ub294 \uac83\uc744 \ucc3e\ub294\ub2e4. \uc704\uc758 \ucf00\uc774\uc2a4\uc5d0\uc11c\ub294 Ordering.Int\uc640 only matching\ub418\uace0 \ucef4\ud30c\uc77c\ub7ec\ub294 method sort\ub85c \uc774\ub97c \uc804\ub2ec\ud55c\ub2e4. sort[Int](xs)(Ordering.Int) candidate values\uac00 \uc5b4\ub5bb\uac8c \uc815\uc758\ub3c4\uc5b4\uc788\ub294 \uc9c0\ub97c \uc0b4\ud3b4 \ubcf4\uae30 \uc804\uc5d0 implicit \ud0a4\uc6cc\ub4dc\uc5d0 \ub300\ud574 \uc790\uc138\ud788 \uc54c\uc544\ubcf4\uc790. method\ub294 \uc624\uc9c1 \ud558\ub098\uc758 implicit parameter list\ub97c \uac00\uc9c8 \uc218 \uc788\uc73c\uba70 \uc774\ub294 \ub9c8\uc9c0\ub9c9 paramter\uac00 \ub418\uc57c \ud55c\ub2e4. At call site, the arguments of the given clause are usually left out, although it is possible to explicitly pass them: // Argument inferred by the compiler sort(xs) // Explicit argument sort(xs)(Ordering.Int.reverse)","title":"Implicit Parameters"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#candidates-for-implicit-parameters","text":"\ucef4\ud30c\uc77c\ub7ec\uac00 type T\uc5d0 \ub300\ud574 \uc5b4\ub5a4 candidate definition\ub97c \ucc3e\uc744\uae4c? \ucef4\ud30c\uc77c\ub7ec\ub294 \uc544\ub798 definition\uc744 \ucc3e\ub294\ub2e4. have type T, are marked implicit, are visible at the point of the function call, or are defined in a companion object associated with T. most specific\ud55c \uc815\uc758\ub97c \ucc3e\uac8c \ub418\uba74 \uadf8\uac83\uc744 \uc0ac\uc6a9\ud558\uace0 \uc5c6\ub2e4\uba74 error\ub97c report\ud55c\ub2e4.","title":"Candidates for Implicit Parameters"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#implicit-definition","text":"implicit definition\uc774\ub780 implicit \ud0a4\uc6cc\ub4dc\uc640 \ud568\uaed8 \uc815\uc758\ub41c \uac83\uc744 \ub9d0\ud55c\ub2e4. object Ordering { implicit val Int: Ordering[Int] = ... } \uc704\uc758 \ucf54\ub4dc\ub294 Int\ub77c\ub294 \uc774\ub984\uc744 \uac00\uc9c4 Ordering[Int] \ud0c0\uc785\uc758 implicit value\ub97c \uc815\uc758\ud55c \uac83\uc774\ub2e4. Any val, lazy val, def, or object definition can be marked implicit. \ub9c8\uc9c0\ub9c9\uc73c\ub85c implicit definitions\ub294 type parameters\uc640 implicit parameters\ub97c \uac00\uc9c8 \uc218 \uc788\ub2e4. implicit def orderingPair[A, B](implicit orderingA: Ordering[A], orderingB: Ordering[B] ): Ordering[(A, B)] = ...","title":"implicit Definition"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#implicit-search-scope","text":"type T\uc758 implicit value\ub97c \ucc3e\uae30 \uc704\ud574 \uccab \ubc88\uc9f8\ub85c visible(inherited, imported, or defined in an enclosing scope)\ud55c \ubaa8\ub4e0 implicit definitions\ub97c \ucc3e\ub294\ub2e4. \ub9cc\uc57d \ucef4\ud30c\uc77c\ub7ec\uac00 lexcial scope\uc5d0\uc11c implicit instance\uc640 \ub9e4\uce6d\ub418\ub294 type T\ub97c \ucc3e\uc9c0 \ubabb\ud558\uba74, T\uc640 \uad00\ub828\ub41c companion objects\uc5d0\uc11c \uc774\uc5b4\uc11c \ucc3e\ub294\ub2e4. (companion objects\uc640 types\ub294 other types\uc640 \uc5f0\uad00\uc788\ub2e4.) A companion object is an object that has the same name as a type. \uc608\ub85c object scala.math.Ordering is the companion of the type scala.math.Ordering. The types associated with a type T are: if T has parent types T\u2081 with T\u2082 ... with T\u2099, the union of the parts of T\u2081, ... T\u2099 as well as T itself, if T is a parameterized type S[T\u2081, T\u2082, ..., T\u2099], the union of the parts of S and T\u2081, ..., T\u2099, otherwise, just T itself. As an example, consider the following type hierarchy: trait Foo[A] trait Bar[A] extends Foo[A] trait Baz[A] extends Bar[A] trait X trait Y extends X \ub9cc\uc57d Bar[Y] \ud0c0\uc785\uc758 implicit value\uac00 \ud544\uc694\ud558\ub2e4\uba74 compiler\ub294 \uc544\ub798\uc640 \uac19\uc740 companion object\uc5d0\uc11c implicit definition\uc744 \ucc3e\uc744 \uac83\uc774\ub2e4. Bar, because it is a part of Bar[Y], Y, because it is a part of Bar[Y], Foo, because it is a parent type of Bar, and X, because it is a parent type of Y. However, the Baz companion object will not be visited.","title":"Implicit Search Scope"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#implicit-search-process","text":"search process\ub294 no candidate found \ud639\uc740 \ub9e4\uce6d\ub418\ub294 \ucd5c\uc18c\ud55c \ud558\ub098\uc758 candidate\ub97c \uacb0\uacfc\ub97c \ub9cc\ub4e4\uc5b4 \ub0b8\ub2e4. \ub9cc\uc57d no no available implicit definition matching \uc774\ub77c\uba74 \uc5d0\ub7ec\uac00 repot \ub41c\ub2e4. scala> def f(implicit n: Int) = () scala> f ^ error: could not find implicit value for parameter n: Int \ubc18\ub300\ub85c \ub458 \uc774\uc0c1\uc758 implicit definition\uc774 eligibale \ud558\ub2e4\uba74 ambiguity\uac00 report \ub41c\ub2e4. scala> implicit val x: Int = 0 scala> implicit val y: Int = 1 scala> def f(implicit n: Int) = () scala> f ^ error: ambiguous implicit values: both value x of type => Int same type\uc5d0 \ub9e4\uce6d\ub418\ub294 several implicit definitions\uac00 \uc788\uc5b4\ub3c4 \ud558\ub098\ub97c \ud2b9\uc815 \ud560 \uc218 \uc788\ub2e4\uba74 \uad1c\ucc2e\ub2e4. A definition a: A is more specific than a definition b: B if: type A has more \u201cfixed\u201d parts, or, a is defined in a class or object which is a subclass of the class defining b. Let\u2019s see a few examples of priorities at work. Which implicit definition matches the Int implicit parameter when the following method f is called? implicit def universal[A]: A = ??? implicit def int: Int = ??? def f(implicit n: Int) = () f \uc704\uc758 \uacbd\uc6b0\uc5d0\uc11c universal\uc740 type paramter\ub97c \uc9c0\ub2c8\uace0 int\ub294 \uc544\ub2c8\uae30\uc5d0, int\uac00 more fixed parts\ub97c \uac16\uace0 \uc774\ub294 universal\ubcf4\ub2e4 \uba3c\uc800 \uace0\ub824\ub41c\ub2e4. \uadf8\ub807\uae30 \ub54c\ubb38\uc5d0 \ucef4\ud30c\uc77c\ub7ec\uac00 int\ub97c \uc120\ud0dd\ud568\uc5d0 \uc788\uc5b4 ambiguity\uac00 \uc5c6\ub2e4. \uc544\ub798\uc640 \uac19\uc774 \uc788\uc744 \ub54c implicit Int \ud30c\ub77c\ubbf8\ud130\ub97c \uac16\ub294 f method\ub294 \uc5b4\ub290 implicit definition\uc5d0 \ub9e4\uce58 \ub420\uae4c? trait A { implicit val x: Int = 0 } trait B extends A { implicit val y: Int = 1 def f(implicit n: Int) = () f } y\uac00 A\ub97c extend\ud558\ub294 trait\uc774\ubbc0\ub85c y\uac00 A\ubcf4\ub2e4 more specific \ud558\ub2e4. \uadf8\ub7ec\ubbc0\ub85c \ucef4\ud30c\uc77c\ub7ec\uac00 y\ub97c \uc120\ud0dd\ud558\ub294 \uac83\uc5d0 ambiguity\ub294 \uc5c6\ub2e4.","title":"Implicit Search Process"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#context-bounds","text":"Syntactic sugar allows the omission of the implicit parameter list: def printSorted[A: Ordering](as: List[A]): Unit = { println(sort(as)) } Type parameter A has one context bound: Ordering. This is equivalent to writing: def printSorted[A](as: List[A])(implicit ev1: Ordering[A]): Unit = { println(sort(as)) } More generally, a method definition such as: def f[A: U\u2081 ... : U\u2099](ps): R = ... Is expanded to: def f[A](ps)(implicit ev\u2081: U\u2081[A], ..., ev\u2099: U\u2099[A]): R = ...","title":"Context Bounds"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#implicit-query","text":"At any point in a program, one can query an implicit value of a given type by calling the implicitly operation: scala> implicitly[Ordering[Int]] res0: Ordering[Int] = scala.math.Ordering$Int$@73564ab0 Note that implicitly is not a special keyword, it is defined as a library operation: def implicitly[A](implicit value: A): A = value","title":"Implicit Query"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#summary","text":"In this lesson we have introduced the concept of type-directed programming, a language mechanism that infers values from types. There has to be a unique (most specific) implicit definition matching the queried type for it to be selected by the compiler. Implicit values are searched in the enclosing lexical scope (imports, parameters, inherited members) as well as in the implicit scope of the queried type. The implicit scope of type is made of implicit values defined in companion objects of types associated with the queried type.","title":"Summary"},{"location":"scala/Coursera/fpd-in-scala/week3_2-typeclasses/","text":"Week3-2: Type Classes In the previous lectures we have seen a particular pattern of code combining parameterized types and implicits. We have defined a parameterized type Ordering[A], implicit instances of that type for concrete types A, and implicit parameters of type Ordering[A]: trait Ordering[A] { def compare(a1: A, a2: A): Int } object Ordering { implicit val Int: Ordering[Int] = new Ordering[Int] { def compare(x: Int, y: Int) = if (x < y) -1 else if (x > y) 1 else 0 } implicit val String: Ordering[String] = new Ordering[String] { def compare(s: String, t: String) = s.compareTo(t) } } def sort[A: Ordering](xs: List[A]): List[A] = ... We say that Ordering is a type class. Type classes provide yet another form of polymorphism. The method sort can be called with lists containing elements of any type A for which there is an implicit value of type Ordering[A]. At compile-time, the compiler resolves the specific Ordering implementation that matches the type of the list elements. Retroactive Extension Type classes let us add new features to data types without changing the original definition of these data types. For instance, consider the following Rational type, modeling a rational number: /** A rational number * @param num Numerator * @param denom Denominator */ case class Rational(num: Int, denom: Int) We can add the capability \"to be compared\" to the type Rational by defining an implicit instance of type Ordering[Rational]: object RationalOrdering { implicit val orderingRational: Ordering[Rational] = new Ordering[Rational] { def compare(q: Rational, r: Rational): Int = q.num * r.denom - r.num * q.denom } } Laws So far, we have shown how to implement instances of a type class, for some specific types (Int, String, and Rational). Now, let\u2019s have a look at the other side: how to use (and reason about) type classes. For example, the sort function is written in terms of the Ordering type class, whose implementation is itself defined by each specific instance, and is therefore unknown at the time the sort function is written. If an Ordering instance implementation is incorrect, then the sort function becomes incorrect too! To prevent this from happening, type classes are often accompanied by laws, which describe properties that instances must satisfy, and that users of type classes can rely on. Can you think of properties that instances of the type class Ordering must satisfy, so that we can be confident that the method sort won\u2019t be broken? Instances of the Ordering[A] type class must satisfy the following properties: inverse: the sign of the result of comparing x and y must be the inverse of the sign of the result of comparing y and x, transitive: if a value x is lower than y and that y is lower than z, then x must also be lower than z, consistent: if two values x and y are equal, then the sign of the result of comparing x and z should be the same as the sign of the result of comparing y and z. The authors of a type class should think about such kind of laws and they should provide ways for instance implementers to check that these laws are satisfied. Example of Type Class: Ring Let\u2019s see how we can define a type class modeling a ring structure. A ring is an algebraic structure defined as follows according to Wikipedia: In mathematics, a ring is one of the fundamental algebraic structures used in abstract algebra. It consists of a set equipped with two binary operations that generalize the arithmetic operations of addition and multiplication. Through this generalization, theorems from arithmetic are extended to non-numerical objects such as polynomials, series, matrices and functions. This structure is so common that, by abstracting over the ring structure, developers could write programs that could then be applied to various domains (arithmetic, polynomials, series, matrices and functions). A ring is a set equipped with two binary operations, + and *, satisfying the following laws (called the ring axioms): (a + b) + c = a + (b + c) + is associative a + b = b + a + is commutative a + 0 = a 0 is the additive identity a + -a = 0 -a is the additive inverse of a (a * b) * c = a * (b * c) * is associative a * 1 = a 1 is the multiplicative identity a * (b + c) = a * b + a * c left distributivity (b + c) * a = b * a + c * a right distributivity Here is how we can define a ring type class in Scala: trait Ring[A] { def plus(x: A, y: A): A def mult(x: A, y: A): A def inverse(x: A): A def zero: A def one: A } Here is how we define an instance of Ring[Int]: object Ring { implicit val ringInt: Ring[Int] = new Ring[Int] { def plus(x: Int, y: Int): Int = x + y def mult(x: Int, y: Int): Int = x * y def inverse(x: Int): Int = -x def zero: Int = 0 def one: Int = 1 } } Finally, this is how we would define a function that checks that the + associativity law is satisfied by a given Ring instance: def plusAssociativity[A](x: A, y: A, z: A)(implicit ring: Ring[A]): Boolean = ring.plus(ring.plus(x, y), z) == ring.plus(x, ring.plus(y, z)) Note: in practice, the standard library already provides a type class Numeric, which models a ring structure. Summary In this lesson we have identified a new programming pattern: type classes. Type classes provide a form of polymorphism: they can be used to implement algorithms that can be applied to various types. The compiler selects the type class implementation for a specific type at compile-time. A type class definition is a trait that takes type parameters and defines operations that apply to these types. Generally, a type class definition is accompanied by laws, checking that implementations of their operations are correct.","title":"Week3-2: Type Classes"},{"location":"scala/Coursera/fpd-in-scala/week3_2-typeclasses/#week3-2-type-classes","text":"In the previous lectures we have seen a particular pattern of code combining parameterized types and implicits. We have defined a parameterized type Ordering[A], implicit instances of that type for concrete types A, and implicit parameters of type Ordering[A]: trait Ordering[A] { def compare(a1: A, a2: A): Int } object Ordering { implicit val Int: Ordering[Int] = new Ordering[Int] { def compare(x: Int, y: Int) = if (x < y) -1 else if (x > y) 1 else 0 } implicit val String: Ordering[String] = new Ordering[String] { def compare(s: String, t: String) = s.compareTo(t) } } def sort[A: Ordering](xs: List[A]): List[A] = ... We say that Ordering is a type class. Type classes provide yet another form of polymorphism. The method sort can be called with lists containing elements of any type A for which there is an implicit value of type Ordering[A]. At compile-time, the compiler resolves the specific Ordering implementation that matches the type of the list elements.","title":"Week3-2: Type Classes"},{"location":"scala/Coursera/fpd-in-scala/week3_2-typeclasses/#retroactive-extension","text":"Type classes let us add new features to data types without changing the original definition of these data types. For instance, consider the following Rational type, modeling a rational number: /** A rational number * @param num Numerator * @param denom Denominator */ case class Rational(num: Int, denom: Int) We can add the capability \"to be compared\" to the type Rational by defining an implicit instance of type Ordering[Rational]: object RationalOrdering { implicit val orderingRational: Ordering[Rational] = new Ordering[Rational] { def compare(q: Rational, r: Rational): Int = q.num * r.denom - r.num * q.denom } }","title":"Retroactive Extension"},{"location":"scala/Coursera/fpd-in-scala/week3_2-typeclasses/#laws","text":"So far, we have shown how to implement instances of a type class, for some specific types (Int, String, and Rational). Now, let\u2019s have a look at the other side: how to use (and reason about) type classes. For example, the sort function is written in terms of the Ordering type class, whose implementation is itself defined by each specific instance, and is therefore unknown at the time the sort function is written. If an Ordering instance implementation is incorrect, then the sort function becomes incorrect too! To prevent this from happening, type classes are often accompanied by laws, which describe properties that instances must satisfy, and that users of type classes can rely on. Can you think of properties that instances of the type class Ordering must satisfy, so that we can be confident that the method sort won\u2019t be broken? Instances of the Ordering[A] type class must satisfy the following properties: inverse: the sign of the result of comparing x and y must be the inverse of the sign of the result of comparing y and x, transitive: if a value x is lower than y and that y is lower than z, then x must also be lower than z, consistent: if two values x and y are equal, then the sign of the result of comparing x and z should be the same as the sign of the result of comparing y and z. The authors of a type class should think about such kind of laws and they should provide ways for instance implementers to check that these laws are satisfied.","title":"Laws"},{"location":"scala/Coursera/fpd-in-scala/week3_2-typeclasses/#example-of-type-class-ring","text":"Let\u2019s see how we can define a type class modeling a ring structure. A ring is an algebraic structure defined as follows according to Wikipedia: In mathematics, a ring is one of the fundamental algebraic structures used in abstract algebra. It consists of a set equipped with two binary operations that generalize the arithmetic operations of addition and multiplication. Through this generalization, theorems from arithmetic are extended to non-numerical objects such as polynomials, series, matrices and functions. This structure is so common that, by abstracting over the ring structure, developers could write programs that could then be applied to various domains (arithmetic, polynomials, series, matrices and functions). A ring is a set equipped with two binary operations, + and *, satisfying the following laws (called the ring axioms): (a + b) + c = a + (b + c) + is associative a + b = b + a + is commutative a + 0 = a 0 is the additive identity a + -a = 0 -a is the additive inverse of a (a * b) * c = a * (b * c) * is associative a * 1 = a 1 is the multiplicative identity a * (b + c) = a * b + a * c left distributivity (b + c) * a = b * a + c * a right distributivity Here is how we can define a ring type class in Scala: trait Ring[A] { def plus(x: A, y: A): A def mult(x: A, y: A): A def inverse(x: A): A def zero: A def one: A } Here is how we define an instance of Ring[Int]: object Ring { implicit val ringInt: Ring[Int] = new Ring[Int] { def plus(x: Int, y: Int): Int = x + y def mult(x: Int, y: Int): Int = x * y def inverse(x: Int): Int = -x def zero: Int = 0 def one: Int = 1 } } Finally, this is how we would define a function that checks that the + associativity law is satisfied by a given Ring instance: def plusAssociativity[A](x: A, y: A, z: A)(implicit ring: Ring[A]): Boolean = ring.plus(ring.plus(x, y), z) == ring.plus(x, ring.plus(y, z)) Note: in practice, the standard library already provides a type class Numeric, which models a ring structure.","title":"Example of Type Class: Ring"},{"location":"scala/Coursera/fpd-in-scala/week3_2-typeclasses/#summary","text":"In this lesson we have identified a new programming pattern: type classes. Type classes provide a form of polymorphism: they can be used to implement algorithms that can be applied to various types. The compiler selects the type class implementation for a specific type at compile-time. A type class definition is a trait that takes type parameters and defines operations that apply to these types. Generally, a type class definition is accompanied by laws, checking that implementations of their operations are correct.","title":"Summary"},{"location":"scala/Coursera/fpd-in-scala/week3_3-ConditionalImplicitDefinitions/","text":"Week3-3: Conditional Implicit Definitions In this lesson, we will see that implicit definitions can themselves take implicit parameters. Let\u2019s start with an example. Consider how we order two String values: is \"abc\" lexicographically before \"abd\"? To answer this question, we need to compare all the characters of the String values, element-wise: is a before a? No. is b before b? No. is c before d? Yes! We conclude that \"abc\" is before \"abd\". So, we compare two sequences of characters with an algorithm that compares the characters of the sequences element-wise. Said otherwise, we can define an ordering relation for sequence of characters based on the ordering relation for characters. Can we generalize this process to sequences of any element type A for which there is an implicit Ordering[A] instance? The signature of such an Ordering[List[A]] definition takes an implicit parameter of type Ordering[A]: implicit def orderingList[A](implicit ord: Ordering[A]): Ordering[List[A]] For reference, a complete implementation is shown below. You can see that at some point in the algorithm we call the operation compare of the ord parameter: implicit def orderingList[A](implicit ord: Ordering[A]): Ordering[List[A]] = new Ordering[List[A]] { def compare(xs: List[A], ys: List[A]) = (xs, ys) match { case (x :: xsTail, y :: ysTail) => val c = ord.compare(x, y) if (c != 0) c else compare(xsTail, ysTail) case (Nil, Nil) => 0 case (_, Nil) => 1 case (Nil, _) => -1 } } With this definition, we can sort a list of list of numbers, for example: scala> val xss = List(List(1, 2, 3), List(1), List(1, 1, 3)) res0: List[List[Int]] = List(List(1, 2, 3), List(1), List(1, 1, 3)) scala> sort(xss) res1: List[List[Int]] = List(List(1), List(1, 1, 3), List(1, 2, 3)) But let\u2019s take a step back. We haven\u2019t defined an instance of Ordering[List[Int]] and yet we have been able to sort a list of List[Int] elements! How did the compiler manage to provide such an instance to us? This happened in several steps. First, we called sort(xss). The compiler fixed the type parameter A of the method to List[Int], based on the type of the argument xss, as if we had written: sort[List[Int]](xss) Then, the compiler searched for an implicit definition of type Ordering[List[Int]]. It found that our orderingList definition could be a match under the condition that it could also find an implicit definition of type Ordering[Int], which it eventually found. Finally, the compiler inserted the following arguments for us: sort[List[Int]](xss)(orderingList(Ordering.Int)) In this case, the compiler combined two implicit definitions (orderingList and Ordering.Int) before terminating. In general, though, an arbitrary number of implicit definitions can be combined until the search hits a \u201cterminal\u201d definition. Consider for instance these four implicit definitions: implicit def a: A = ... implicit def aToB(implicit a: A): B = ... implicit def bToC(implicit b: B): C = ... implicit def cToD(implicit c: C): D = ... We can then ask the compiler to summon a value of type D: implicitly[D] The compiler finds that there is a candidate definition, cToD, that can provide such a D value, under the condition that it can also find an implicit definition of type C. Again, it finds that there is a candidate definition, bToC, that can provide such a C value, under the condition that it can also find an implicit definition of type B. Once again, it finds that there is candidate definition, aToB, that can provide such a B value, under the condition that it can also find an implicit value of type A. Finally, it finds a candidate definition for type A and the algorithm terminates! At the beginning of this lesson, we showed that by using implicit parameters the compiler could infer simple arguments for us. We have now reached a point where we can appreciate that the compiler can infer more complex arguments (by inferring arguments of arguments!). It not only significantly reduces code verbosity, it also alleviates developers from implementing parts of their programs, which are summoned by the compiler based on their type (hence the name \u201ctype-directed programming\u201d). In practice, complex fragments of programs such as serializers and deserializers of data types can be summoned by the compiler. Recursive Implicit Definitions What happens if we write an implicit definition that depends on itself? trait X implicit def loop(implicit x: X): X = x implicitly[X] The compiler detects that it keeps searching for an implicit definition of the same type and returns an error: error: diverging implicit expansion for type X starting with method loop Note: it is possible to write recursive implicit definitions by making sure that the search always terminates, but this is out of the scope of this lesson. Example: Sort by Multiple Criteria Consider a situation where we want to compare several movies. Each movie has a title, a rating (in number of \u201cstars\u201d), and a duration (in minutes): case class Movie(title: String, rating: Int, duration: Int) val movies = Seq( Movie(\"Interstellar\", 9, 169), Movie(\"Inglourious Basterds\", 8, 140), Movie(\"Fight Club\", 9, 139), Movie(\"Zodiac\", 8, 157) ) We want to sort movies by rating first, and then by duration. To achieve this, a first step is to change our sort function to take as parameter the sort criteria in addition to the elements to sort: def sort[A, B](elements: Seq[A])(critera: A => B)(implicit ord: Ordering[B] ): Seq[A] = ... The sort algorithm remains the same except that instead of comparing the elements together, we compare the criteria applied to each element. With this function, here is how we can sort movies by title: sort(movies)(_.title) And here is how we can sort them by rating: sort(movies)(_.rating) Each time the sort function is called, its ordering parameter is inferred by the compiler based on the type of the criteria (String and then Int, in the above examples). However, our initial problem was to sort the movies by multiple criteria. We would like to sort first by rating and then by duration: sort(movies)(movie => (movie.rating, movie.duration)) The type of the criteria is now a tuple type (Int, Int). Unfortunately, the compiler is unable to infer the corresponding ordering parameter. We need to define how simple orderings can be combined together to get an ordering for multiple criteria. We do so by defining the following implicit ordering: implicit def orderingPair[A, B](implicit orderingA: Ordering[A], orderingB: Ordering[B] ): Ordering[(A, B)] = ... This definition provides an ordering for pairs of type (A, B) given orderings for types A and B. The complete implementation is the following: implicit def orderingPair[A, B](implicit orderingA: Ordering[A], orderingB: Ordering[B] ): Ordering[(A, B)] = new Ordering[(A, B)] { def compare(pair1: (A, B), pair2: (A, B)): Int = { val firstCriteria = orderingA.compare(pair1._1, pair2._1) if (firstCriteria != 0) firstCriteria else orderingB.compare(pair1._2, pair2._2) } } We first compare the two values according to the first criteria, and if they are equal we compare them according to the second criteria. With this definition, the compiler is now able to infer the ordering for the following call: sort(movies)(movie => (movie.rating, movie.duration)) Here is the same call where the inferred parameter is explicitly written: sort(movies)(movie => (movie.rating, movie.duration))( orderingPair(Ordering.Int, Ordering.Int) ) Note that in the standard library the sort function that we have defined here is already available as a method sortBy on collections. Summary In this lesson, we have seen that: implicit definitions can also take implicit parameters, an arbitrary number of implicit definitions can be chained until a terminal definition is reached.","title":"Week3-3: Conditional Implicit Definitions"},{"location":"scala/Coursera/fpd-in-scala/week3_3-ConditionalImplicitDefinitions/#week3-3-conditional-implicit-definitions","text":"In this lesson, we will see that implicit definitions can themselves take implicit parameters. Let\u2019s start with an example. Consider how we order two String values: is \"abc\" lexicographically before \"abd\"? To answer this question, we need to compare all the characters of the String values, element-wise: is a before a? No. is b before b? No. is c before d? Yes! We conclude that \"abc\" is before \"abd\". So, we compare two sequences of characters with an algorithm that compares the characters of the sequences element-wise. Said otherwise, we can define an ordering relation for sequence of characters based on the ordering relation for characters. Can we generalize this process to sequences of any element type A for which there is an implicit Ordering[A] instance? The signature of such an Ordering[List[A]] definition takes an implicit parameter of type Ordering[A]: implicit def orderingList[A](implicit ord: Ordering[A]): Ordering[List[A]] For reference, a complete implementation is shown below. You can see that at some point in the algorithm we call the operation compare of the ord parameter: implicit def orderingList[A](implicit ord: Ordering[A]): Ordering[List[A]] = new Ordering[List[A]] { def compare(xs: List[A], ys: List[A]) = (xs, ys) match { case (x :: xsTail, y :: ysTail) => val c = ord.compare(x, y) if (c != 0) c else compare(xsTail, ysTail) case (Nil, Nil) => 0 case (_, Nil) => 1 case (Nil, _) => -1 } } With this definition, we can sort a list of list of numbers, for example: scala> val xss = List(List(1, 2, 3), List(1), List(1, 1, 3)) res0: List[List[Int]] = List(List(1, 2, 3), List(1), List(1, 1, 3)) scala> sort(xss) res1: List[List[Int]] = List(List(1), List(1, 1, 3), List(1, 2, 3)) But let\u2019s take a step back. We haven\u2019t defined an instance of Ordering[List[Int]] and yet we have been able to sort a list of List[Int] elements! How did the compiler manage to provide such an instance to us? This happened in several steps. First, we called sort(xss). The compiler fixed the type parameter A of the method to List[Int], based on the type of the argument xss, as if we had written: sort[List[Int]](xss) Then, the compiler searched for an implicit definition of type Ordering[List[Int]]. It found that our orderingList definition could be a match under the condition that it could also find an implicit definition of type Ordering[Int], which it eventually found. Finally, the compiler inserted the following arguments for us: sort[List[Int]](xss)(orderingList(Ordering.Int)) In this case, the compiler combined two implicit definitions (orderingList and Ordering.Int) before terminating. In general, though, an arbitrary number of implicit definitions can be combined until the search hits a \u201cterminal\u201d definition. Consider for instance these four implicit definitions: implicit def a: A = ... implicit def aToB(implicit a: A): B = ... implicit def bToC(implicit b: B): C = ... implicit def cToD(implicit c: C): D = ... We can then ask the compiler to summon a value of type D: implicitly[D] The compiler finds that there is a candidate definition, cToD, that can provide such a D value, under the condition that it can also find an implicit definition of type C. Again, it finds that there is a candidate definition, bToC, that can provide such a C value, under the condition that it can also find an implicit definition of type B. Once again, it finds that there is candidate definition, aToB, that can provide such a B value, under the condition that it can also find an implicit value of type A. Finally, it finds a candidate definition for type A and the algorithm terminates! At the beginning of this lesson, we showed that by using implicit parameters the compiler could infer simple arguments for us. We have now reached a point where we can appreciate that the compiler can infer more complex arguments (by inferring arguments of arguments!). It not only significantly reduces code verbosity, it also alleviates developers from implementing parts of their programs, which are summoned by the compiler based on their type (hence the name \u201ctype-directed programming\u201d). In practice, complex fragments of programs such as serializers and deserializers of data types can be summoned by the compiler.","title":"Week3-3: Conditional Implicit Definitions"},{"location":"scala/Coursera/fpd-in-scala/week3_3-ConditionalImplicitDefinitions/#recursive-implicit-definitions","text":"What happens if we write an implicit definition that depends on itself? trait X implicit def loop(implicit x: X): X = x implicitly[X] The compiler detects that it keeps searching for an implicit definition of the same type and returns an error: error: diverging implicit expansion for type X starting with method loop Note: it is possible to write recursive implicit definitions by making sure that the search always terminates, but this is out of the scope of this lesson.","title":"Recursive Implicit Definitions"},{"location":"scala/Coursera/fpd-in-scala/week3_3-ConditionalImplicitDefinitions/#example-sort-by-multiple-criteria","text":"Consider a situation where we want to compare several movies. Each movie has a title, a rating (in number of \u201cstars\u201d), and a duration (in minutes): case class Movie(title: String, rating: Int, duration: Int) val movies = Seq( Movie(\"Interstellar\", 9, 169), Movie(\"Inglourious Basterds\", 8, 140), Movie(\"Fight Club\", 9, 139), Movie(\"Zodiac\", 8, 157) ) We want to sort movies by rating first, and then by duration. To achieve this, a first step is to change our sort function to take as parameter the sort criteria in addition to the elements to sort: def sort[A, B](elements: Seq[A])(critera: A => B)(implicit ord: Ordering[B] ): Seq[A] = ... The sort algorithm remains the same except that instead of comparing the elements together, we compare the criteria applied to each element. With this function, here is how we can sort movies by title: sort(movies)(_.title) And here is how we can sort them by rating: sort(movies)(_.rating) Each time the sort function is called, its ordering parameter is inferred by the compiler based on the type of the criteria (String and then Int, in the above examples). However, our initial problem was to sort the movies by multiple criteria. We would like to sort first by rating and then by duration: sort(movies)(movie => (movie.rating, movie.duration)) The type of the criteria is now a tuple type (Int, Int). Unfortunately, the compiler is unable to infer the corresponding ordering parameter. We need to define how simple orderings can be combined together to get an ordering for multiple criteria. We do so by defining the following implicit ordering: implicit def orderingPair[A, B](implicit orderingA: Ordering[A], orderingB: Ordering[B] ): Ordering[(A, B)] = ... This definition provides an ordering for pairs of type (A, B) given orderings for types A and B. The complete implementation is the following: implicit def orderingPair[A, B](implicit orderingA: Ordering[A], orderingB: Ordering[B] ): Ordering[(A, B)] = new Ordering[(A, B)] { def compare(pair1: (A, B), pair2: (A, B)): Int = { val firstCriteria = orderingA.compare(pair1._1, pair2._1) if (firstCriteria != 0) firstCriteria else orderingB.compare(pair1._2, pair2._2) } } We first compare the two values according to the first criteria, and if they are equal we compare them according to the second criteria. With this definition, the compiler is now able to infer the ordering for the following call: sort(movies)(movie => (movie.rating, movie.duration)) Here is the same call where the inferred parameter is explicitly written: sort(movies)(movie => (movie.rating, movie.duration))( orderingPair(Ordering.Int, Ordering.Int) ) Note that in the standard library the sort function that we have defined here is already available as a method sortBy on collections.","title":"Example: Sort by Multiple Criteria"},{"location":"scala/Coursera/fpd-in-scala/week3_3-ConditionalImplicitDefinitions/#summary","text":"In this lesson, we have seen that: implicit definitions can also take implicit parameters, an arbitrary number of implicit definitions can be chained until a terminal definition is reached.","title":"Summary"},{"location":"scala/Coursera/fpp-in-scala/week1/","text":"substitution model \ud568\uc218\uc758 argument\ub97c \uc67c\ucabd\ubd80\ud130 \ubaa8\ub450 \ud3c9\uac00 \ud568\uc218\uc758 \uc624\ub978\ucabd\ubd80\ud130 \uad50\uccb4 -> \ubaa8\ub4e0 Expression\uc5d0 \uc0ac\uc6a9 \uac00\ub2a5 , No side effect foundation of functional programming\uc778 \ub78c\ub2e4 calculus\uc5d0 formalized \ub418\uc5b4\uc788\ub2e4. \ubaa8\ub4e0 Expr\uc774 reduce to a value? (X) \uc544\ub798\uc640 \uac19\uc740 \uc608\uac00 \uc788\ub2e4. def loop: Int = loop Evaluation Stratigies CBV(Call By Value), CBN(Call By Name) - CBV: \ubaa8\ub4e0 args\ub294 \ud55c \ubc88\ub9cc \ud3c9\uac00\ud55c\ub2e4\ub294 \uc7a5\uc810 - CBN: \ud638\ucd9c \ub420 \ub54c\uae4c\uc9c0 not evaluted\ub41c\ub2e4\ub294 \uc7a5\uc810 \ub9cc\uc57d CBV\uac00 \uc885\ub8cc\ub41c\ub2e4\uba74 CBN\ub3c4 \uc885\ub8cc\ub41c\ub2e4? (O) \ubc18\ub300\ub85c CBN\uc774 \uc885\ub8cc\ub41c\ub2e4\uba74 CBV\ub3c4 \uc885\ub8cc\ub41c\ub2e4? (X) scala\uc5d0\uc11c CBN\uc744 \uc4f0\ub294 \ubc29\ubc95\uc740 parameter\uc5d0 => \ub97c \ubd99\uc774\uba74 \ub41c\ub2e4. def myFunc(a:=> Int) = a Value Definitions val x = 2 val y = square(x) // \ubc14\ub85c \ud3c9\uac00\ub41c\ub2e4. def loop: Boolean = loop def x = loop // (O) def\ub294 \ud638\ucd9c\ub420\ub54c \ud3c9\uac00\ub41c\ub2e4. val x = loop // (X) Error def and(x: Boolean, y: Boolean) = if (x) y else false and(false, loop) // (X) Error def and2(x: Boolean, y:=> Boolean) = if (x) y else false and2(false, loop) // false Nested Functions small func\ub85c \ubd84\ub9ac\ud558\ub294 \uac83. good FP styles sqrtIter, imporve \uac19\uc740 \ud568\uc218\ub4e4\uc740 \uc678\ubd80\uc5d0 \uacf5\uac1c(direct \ud638\ucd9c) \ud558\uace0 \uc2f6\uc9c0 \uc54a\uc744 \uc218 \uc788\ub2e4. \uc774\ub7ec\ud55c \ubcf4\uc870 \ud568\uc218\ub4e4\uc744 \ub0b4\ubd80 \ud568\uc218\ub85c \ub460\uc73c\ub85c\uc368 name-space pollution\uc744 \ubc29\uc9c0\ud560 \uc218 \uc788\ub2e4. def sqrt(x: Double) = { def improve def sqrtIter } Lexical Scoping outer block\uc5d0 \uc788\ub294 definitions\ub294 inside block\uc5d0\uc11c visible\ud558\ub2e4. \ubcf4\ud1b5 \ubb38\uc7a5 \ub77c\uc778 \ub05d ; \ub294 optional\uc774\ub2e4. \ub2e4\ub9cc \ud55c \ubb38\uc7a5\uc5d0 \uc5ec\ub7ec expr\uc744 \ud45c\ud604\ud560 \ub54c\ub294 \ud544\uc218 \uc774\ub2e4. val y = x + 1; y + y Tail Recursion calls itself as its last action. the function's stack frame can be reused (one stack frame\uc774 \ud544\uc694\ud558\uba70, tail calls \ub77c\uace0 \ud568) @tailrec annotation\uc744 \ud568\uc218 \uc704\uc5d0 \ucd94\uac00\ud558\uba74 \ud574\ub2f9 \ud568\uc218\uac00 tail recur \ud558\uc9c0 \uc54a\uc744 \uc2dc \uc624\ub958\uac00 \ubc1c\uc0dd\ud55c\ub2e4. \uc544\ub798\uc758 factorial \ud568\uc218\ub294 tailrc \ud568\uc218\uac00 \uc544\ub2c8\uba70 gcd\ub294 tailrec \ud568\uc218\uc774\ub2e4. def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) def factorial(n: Int): Int = if (n == 0) 1 else n * factorial(n - 1) \uadf8 \ucc28\uc774\ub294 gcd\ub294 \uc2a4\ud15d\uc744 \uc9c4\ud589\uc744 \uacc4\uc18d \ud558\ub354\ub77c\ub3c4 \ubcf8\uc778 \ud638\ucd9c\ub9cc \uacc4\uc18d \ud558\uac8c \ub418\uc9c0\ub9cc factorial \uac19\uc740 \uacbd\uc6b0\uc5d0\ub294 \uc88c\uce21\uc774 \uacc4\uc18d \ub298\uc5b4\ub09c\ub2e4 4 * factorial(3) \uc774\ub97c tail recursive \ud558\uac8c \ubcc0\uacbd\ud558\uba74 \uc544\ub798\uc640 \uac19\ub2e4. def factorial(n: Int): Int = { @tailrec def loop(acc: Int, n: Int): Int = if (n == 0) acc else loop(acc * n, n -1) loop(1, n) } Donal Knuth said premature optimization is the source of the evil","title":"Week1"},{"location":"scala/Coursera/fpp-in-scala/week1/#substitution-model","text":"\ud568\uc218\uc758 argument\ub97c \uc67c\ucabd\ubd80\ud130 \ubaa8\ub450 \ud3c9\uac00 \ud568\uc218\uc758 \uc624\ub978\ucabd\ubd80\ud130 \uad50\uccb4 -> \ubaa8\ub4e0 Expression\uc5d0 \uc0ac\uc6a9 \uac00\ub2a5 , No side effect foundation of functional programming\uc778 \ub78c\ub2e4 calculus\uc5d0 formalized \ub418\uc5b4\uc788\ub2e4. \ubaa8\ub4e0 Expr\uc774 reduce to a value? (X) \uc544\ub798\uc640 \uac19\uc740 \uc608\uac00 \uc788\ub2e4. def loop: Int = loop","title":"substitution model"},{"location":"scala/Coursera/fpp-in-scala/week1/#evaluation-stratigies","text":"CBV(Call By Value), CBN(Call By Name) - CBV: \ubaa8\ub4e0 args\ub294 \ud55c \ubc88\ub9cc \ud3c9\uac00\ud55c\ub2e4\ub294 \uc7a5\uc810 - CBN: \ud638\ucd9c \ub420 \ub54c\uae4c\uc9c0 not evaluted\ub41c\ub2e4\ub294 \uc7a5\uc810 \ub9cc\uc57d CBV\uac00 \uc885\ub8cc\ub41c\ub2e4\uba74 CBN\ub3c4 \uc885\ub8cc\ub41c\ub2e4? (O) \ubc18\ub300\ub85c CBN\uc774 \uc885\ub8cc\ub41c\ub2e4\uba74 CBV\ub3c4 \uc885\ub8cc\ub41c\ub2e4? (X) scala\uc5d0\uc11c CBN\uc744 \uc4f0\ub294 \ubc29\ubc95\uc740 parameter\uc5d0 => \ub97c \ubd99\uc774\uba74 \ub41c\ub2e4. def myFunc(a:=> Int) = a","title":"Evaluation Stratigies"},{"location":"scala/Coursera/fpp-in-scala/week1/#value-definitions","text":"val x = 2 val y = square(x) // \ubc14\ub85c \ud3c9\uac00\ub41c\ub2e4. def loop: Boolean = loop def x = loop // (O) def\ub294 \ud638\ucd9c\ub420\ub54c \ud3c9\uac00\ub41c\ub2e4. val x = loop // (X) Error def and(x: Boolean, y: Boolean) = if (x) y else false and(false, loop) // (X) Error def and2(x: Boolean, y:=> Boolean) = if (x) y else false and2(false, loop) // false","title":"Value Definitions"},{"location":"scala/Coursera/fpp-in-scala/week1/#nested-functions","text":"small func\ub85c \ubd84\ub9ac\ud558\ub294 \uac83. good FP styles sqrtIter, imporve \uac19\uc740 \ud568\uc218\ub4e4\uc740 \uc678\ubd80\uc5d0 \uacf5\uac1c(direct \ud638\ucd9c) \ud558\uace0 \uc2f6\uc9c0 \uc54a\uc744 \uc218 \uc788\ub2e4. \uc774\ub7ec\ud55c \ubcf4\uc870 \ud568\uc218\ub4e4\uc744 \ub0b4\ubd80 \ud568\uc218\ub85c \ub460\uc73c\ub85c\uc368 name-space pollution\uc744 \ubc29\uc9c0\ud560 \uc218 \uc788\ub2e4. def sqrt(x: Double) = { def improve def sqrtIter }","title":"Nested Functions"},{"location":"scala/Coursera/fpp-in-scala/week1/#lexical-scoping","text":"outer block\uc5d0 \uc788\ub294 definitions\ub294 inside block\uc5d0\uc11c visible\ud558\ub2e4. \ubcf4\ud1b5 \ubb38\uc7a5 \ub77c\uc778 \ub05d ; \ub294 optional\uc774\ub2e4. \ub2e4\ub9cc \ud55c \ubb38\uc7a5\uc5d0 \uc5ec\ub7ec expr\uc744 \ud45c\ud604\ud560 \ub54c\ub294 \ud544\uc218 \uc774\ub2e4. val y = x + 1; y + y","title":"Lexical Scoping"},{"location":"scala/Coursera/fpp-in-scala/week1/#tail-recursion","text":"calls itself as its last action. the function's stack frame can be reused (one stack frame\uc774 \ud544\uc694\ud558\uba70, tail calls \ub77c\uace0 \ud568) @tailrec annotation\uc744 \ud568\uc218 \uc704\uc5d0 \ucd94\uac00\ud558\uba74 \ud574\ub2f9 \ud568\uc218\uac00 tail recur \ud558\uc9c0 \uc54a\uc744 \uc2dc \uc624\ub958\uac00 \ubc1c\uc0dd\ud55c\ub2e4. \uc544\ub798\uc758 factorial \ud568\uc218\ub294 tailrc \ud568\uc218\uac00 \uc544\ub2c8\uba70 gcd\ub294 tailrec \ud568\uc218\uc774\ub2e4. def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) def factorial(n: Int): Int = if (n == 0) 1 else n * factorial(n - 1) \uadf8 \ucc28\uc774\ub294 gcd\ub294 \uc2a4\ud15d\uc744 \uc9c4\ud589\uc744 \uacc4\uc18d \ud558\ub354\ub77c\ub3c4 \ubcf8\uc778 \ud638\ucd9c\ub9cc \uacc4\uc18d \ud558\uac8c \ub418\uc9c0\ub9cc factorial \uac19\uc740 \uacbd\uc6b0\uc5d0\ub294 \uc88c\uce21\uc774 \uacc4\uc18d \ub298\uc5b4\ub09c\ub2e4 4 * factorial(3) \uc774\ub97c tail recursive \ud558\uac8c \ubcc0\uacbd\ud558\uba74 \uc544\ub798\uc640 \uac19\ub2e4. def factorial(n: Int): Int = { @tailrec def loop(acc: Int, n: Int): Int = if (n == 0) acc else loop(acc * n, n -1) loop(1, n) } Donal Knuth said premature optimization is the source of the evil","title":"Tail Recursion"},{"location":"scala/Coursera/fpp-in-scala/week1_1-ProgrammingParadigms/","text":"Lecture 1.1 - Programming Paradigms functional Programming\uc740 paradigm\uc774\ub2e4. classical imperative paradimg(Java or C)\uacfc \uc57d\uac04 \ub2e4\ub978. scala\uc5d0\uc11c\ub294 \uc774 2\uac1c\uc758 paradigm\uc744 \ud569\uce60 \uc218\ub3c4 \uc788\ub2e4. \uc774\ub294 \ub2e4\ub978 \uc5b8\uc5b4\uc5d0\uc11c\uc758 migration\uc744 \uc27d\uac8c \ud574\uc900\ub2e4. In science, a paradigm describes distinct concepts or thought patterns in some scientific discipline. Main Programming Paradigms: - imperative programming - functional programming - logic programming object-oriented programming\ub3c4 paradigm\uc774\ub77c\uace0 \ud558\ub294 \uc0ac\ub78c\ub4e4\ub3c4 \uc788\uc9c0\ub9cc \uc790\uc2e0\uc758 \uc0dd\uac01\uc73c\ub85c\ub294 \uc704 3\uac1c\uc758 \uad50\ucc28\uc810\uc5d0 \uc788\ub2e4\uace0 \uc0dd\uac01\ud55c\ub2e4. Imperative Programming modifying mutable variables using assignments and control structures such as if-then-else, loops, break, continue, return Von Neumann computer\uc758 sequence\ub97c \uc774\ud574\ud558\ub294 \uac83\uc740 imperative program\uc744 \uc774\ud574\ud558\ub294 most common informal way\uc774\ub2e4. Processor <------BUS ------> Memory Problem: Scaling up. How can we avoid conceptualizing programs word by word? high-level abstractions(collections, polynomials, geomtric shapes, strings, documents..)\ub97c \uc815\uc758\ud558\ub294 \ud14c\ud06c\ub2c9\uc774 \ud544\uc694\ud558\ub2e4. Ideally: Develop theories of collections, shapes, strings, ... What is a theory A theory consist of - one or more data types - operations on these types - laws that describe the relationships between values and operations \ubcf4\ud1b5 theory\ub294 mutations \ub97c describe\ud558\uc9c0 \uc54a\ub294\ub2e4! mutation: identity\ub294 \uc720\uc9c0\ud558\uba74\uc11c something\uc744 change\ud558\ub294 \uac83\uc774\ub2e4. Theories without mutations theory of polynomials (a x + b) + (c x + d) = (a+c)*x + (b+d) theory of strings (a ++ b) ++ c = a ++ (b ++ c) Consequences for Programming mathematical theroies\ub97c \ub530\ub974\uba74\uc11c high-level concepts \uad6c\ud604\uc744 \ud558\ub824\uba74 mutation\uc740 \uc5c6\uc5b4\uc57c \ud55c\ub2e4. - theroies do not admit it - mutation\uc740 theories\uc758 useful laws\ub97c destoy \ud560 \uc218 \uc788\ub2e4. \uadf8\ub7ec\ubbc0\ub85c - concentrate on defining theories for operators expressed as functions - avoid mutations - have powerful ways to abstract and compose functions start of function programming means avoid mutations Functional Programming In a restricted sense, FP means programming without mutable variables, assignments, loops, and other imperative control structures In a wider sense, FP meas focusing on the functions In particular, functions can be valuses that are produced, consumed, and composed All this becomes easier in a functional language Functional Programming Language In a restricted sense, a functional programming language is one which does not have mutable variables, assignments, or imperative control structures. In a wider sense, a functional programming language enables the construction of elegant programs that focus on functions. In particular, functions in a FP language are first-class citizens. This means they can be defined anywhere, including inside other functions like any other value, they can be passed as parameters to functions and returned as results as for other values, there exists a set operators to compose functions Some functional programming languages In the restricted sense: - Pure Lisp, XSLT, XPath, XQuery, FP - Haskell (without I/O Monad or UnsafePerformIO) In the wider sense: - Lisp, Scheme, Racket, Clojure \u25b6 SML, Ocaml, F# - Haskell (full language) - Scala - Smalltalk, Ruby (!) Why Functional Programming? Functional Programming is becoming increasingly popular because it offers the following benfits. - simpler reasoning principles - better modularity - good for exploiting parallelism for multicore and cloud computing. my summary \uc6b0\ub9ac\ub294 \uc218\ud559\uc744 \ubc30\uc6b0\uba74\uc11c mutable variables\ub97c \ubc30\uc6b4 \uc801\uc774 \uc5c6\ub2e4. 1 + 1 = 2\uc774\uace0 a + b = 3 \uc774\ub77c\uba74 \uadf8\ub0e5 3\uc778 \uac83\uc774\ub2e4. \uc624\ub298\uc740 a + b = 3 \uc774\uc5c8\ub294\ub370 \ub0b4\uc77c\uc740 a + b = 4\uc77c \uc21c \uc5c6\uc5c8\ub2e4. (ax^2 + bx + c \ub294 \uc5ec\ub7ec \uac12\uc774 \ub420 \uc218 \uc788\uaca0\uc9c0\ub9cc) \ud558\uc9c0\ub9cc imperative programming\uc5d0\uc11c\ub294 \uc790\uc5f0\uc2a4\ub7ec\uc6b4 \uac1c\ub150\uc774\ub2e4. int a = 1; int b = 2; a + b = 3; a = 4; a + b = 6; \uc65c \uc218\ud559\uc801\uc778 \uc6d0\uce59\uc744 \uaebc\ub0b4 \ub4e4\uc5c8\ub0d0? module\ud654 \ub54c\ubb38\uc774\ub2e4. \ud504\ub85c\uadf8\ub7a8\uc774 \ubcf5\uc7a1\ud574\uc9c0\uba74\uc11c \ubaa8\ub4c8\ud654\ub294 \ud544\uc218\uc774\ub2e4. \uc798 \ub41c \ubaa8\ub4c8\ud654\ub780 \ubb34\uc5c7\uc77c\uae4c? \ud56d\uc0c1 \ub3d9\uc77c\ud55c \uacb0\uacfc\ub97c \ub9ac\ud134\ud558\ub294 \ubaa8\ub4c8\uc77c \uac83\uc774\ub2e4. map \ud568\uc218\ub97c \uc0dd\uac01\ud574\ubcf4\uba74 \uc5b4\ub290 \ud0c0\uc785\uc5d0 \uc0c1\uad00\uc5c6\uc774 List[U]\ub97c \ub9ac\ud134\ud55c\ub2e4. \uc774\ub7f0 \uc218\ud559\uc801 \uc6d0\uce59\ub4e4\uc740 mutable variables\ub97c \uc778\uc815\ud558\uc9c0 \uc54a\ub294\ub2e4. \uadf8\ub807\uae30\uc5d0 functional programming language\uc5d0 \uc798 \ub9de\ub294\ub2e4. fp\ub294 \uc774\ub7f0 \ubaa8\ud638\ud568\uc744 \uc81c\uac70\ud568\uc73c\ub85c\uc11c \uc6d0\uce59\uc744 \ubcf4\ub2e4 \uc798 \uad6c\ud604\ud558\uace0 \ubaa8\ub4c8\ud654 \ud558\uae30 \uc88b\uc73c\uba70 multicore\uc640 cloud computing \ud658\uacbd\uc5d0\uc11c \ubcd1\ub82c\ucc98\ub9ac\ub97c \uc798 \ud560 \uc218 \uc788\uac8c \ud574\uc900\ub2e4.","title":"Lecture 1.1 - Programming Paradigms"},{"location":"scala/Coursera/fpp-in-scala/week1_1-ProgrammingParadigms/#lecture-11-programming-paradigms","text":"functional Programming\uc740 paradigm\uc774\ub2e4. classical imperative paradimg(Java or C)\uacfc \uc57d\uac04 \ub2e4\ub978. scala\uc5d0\uc11c\ub294 \uc774 2\uac1c\uc758 paradigm\uc744 \ud569\uce60 \uc218\ub3c4 \uc788\ub2e4. \uc774\ub294 \ub2e4\ub978 \uc5b8\uc5b4\uc5d0\uc11c\uc758 migration\uc744 \uc27d\uac8c \ud574\uc900\ub2e4. In science, a paradigm describes distinct concepts or thought patterns in some scientific discipline. Main Programming Paradigms: - imperative programming - functional programming - logic programming object-oriented programming\ub3c4 paradigm\uc774\ub77c\uace0 \ud558\ub294 \uc0ac\ub78c\ub4e4\ub3c4 \uc788\uc9c0\ub9cc \uc790\uc2e0\uc758 \uc0dd\uac01\uc73c\ub85c\ub294 \uc704 3\uac1c\uc758 \uad50\ucc28\uc810\uc5d0 \uc788\ub2e4\uace0 \uc0dd\uac01\ud55c\ub2e4.","title":"Lecture 1.1 - Programming Paradigms"},{"location":"scala/Coursera/fpp-in-scala/week1_1-ProgrammingParadigms/#imperative-programming","text":"modifying mutable variables using assignments and control structures such as if-then-else, loops, break, continue, return Von Neumann computer\uc758 sequence\ub97c \uc774\ud574\ud558\ub294 \uac83\uc740 imperative program\uc744 \uc774\ud574\ud558\ub294 most common informal way\uc774\ub2e4. Processor <------BUS ------> Memory Problem: Scaling up. How can we avoid conceptualizing programs word by word? high-level abstractions(collections, polynomials, geomtric shapes, strings, documents..)\ub97c \uc815\uc758\ud558\ub294 \ud14c\ud06c\ub2c9\uc774 \ud544\uc694\ud558\ub2e4. Ideally: Develop theories of collections, shapes, strings, ...","title":"Imperative Programming"},{"location":"scala/Coursera/fpp-in-scala/week1_1-ProgrammingParadigms/#what-is-a-theory","text":"A theory consist of - one or more data types - operations on these types - laws that describe the relationships between values and operations \ubcf4\ud1b5 theory\ub294 mutations \ub97c describe\ud558\uc9c0 \uc54a\ub294\ub2e4! mutation: identity\ub294 \uc720\uc9c0\ud558\uba74\uc11c something\uc744 change\ud558\ub294 \uac83\uc774\ub2e4.","title":"What is a theory"},{"location":"scala/Coursera/fpp-in-scala/week1_1-ProgrammingParadigms/#theories-without-mutations","text":"theory of polynomials (a x + b) + (c x + d) = (a+c)*x + (b+d) theory of strings (a ++ b) ++ c = a ++ (b ++ c)","title":"Theories without mutations"},{"location":"scala/Coursera/fpp-in-scala/week1_1-ProgrammingParadigms/#consequences-for-programming","text":"mathematical theroies\ub97c \ub530\ub974\uba74\uc11c high-level concepts \uad6c\ud604\uc744 \ud558\ub824\uba74 mutation\uc740 \uc5c6\uc5b4\uc57c \ud55c\ub2e4. - theroies do not admit it - mutation\uc740 theories\uc758 useful laws\ub97c destoy \ud560 \uc218 \uc788\ub2e4. \uadf8\ub7ec\ubbc0\ub85c - concentrate on defining theories for operators expressed as functions - avoid mutations - have powerful ways to abstract and compose functions start of function programming means avoid mutations","title":"Consequences for Programming"},{"location":"scala/Coursera/fpp-in-scala/week1_1-ProgrammingParadigms/#functional-programming","text":"In a restricted sense, FP means programming without mutable variables, assignments, loops, and other imperative control structures In a wider sense, FP meas focusing on the functions In particular, functions can be valuses that are produced, consumed, and composed All this becomes easier in a functional language","title":"Functional Programming"},{"location":"scala/Coursera/fpp-in-scala/week1_1-ProgrammingParadigms/#functional-programming-language","text":"In a restricted sense, a functional programming language is one which does not have mutable variables, assignments, or imperative control structures. In a wider sense, a functional programming language enables the construction of elegant programs that focus on functions. In particular, functions in a FP language are first-class citizens. This means they can be defined anywhere, including inside other functions like any other value, they can be passed as parameters to functions and returned as results as for other values, there exists a set operators to compose functions","title":"Functional Programming Language"},{"location":"scala/Coursera/fpp-in-scala/week1_1-ProgrammingParadigms/#some-functional-programming-languages","text":"In the restricted sense: - Pure Lisp, XSLT, XPath, XQuery, FP - Haskell (without I/O Monad or UnsafePerformIO) In the wider sense: - Lisp, Scheme, Racket, Clojure \u25b6 SML, Ocaml, F# - Haskell (full language) - Scala - Smalltalk, Ruby (!)","title":"Some functional programming languages"},{"location":"scala/Coursera/fpp-in-scala/week1_1-ProgrammingParadigms/#why-functional-programming","text":"Functional Programming is becoming increasingly popular because it offers the following benfits. - simpler reasoning principles - better modularity - good for exploiting parallelism for multicore and cloud computing.","title":"Why Functional Programming?"},{"location":"scala/Coursera/fpp-in-scala/week1_1-ProgrammingParadigms/#my-summary","text":"\uc6b0\ub9ac\ub294 \uc218\ud559\uc744 \ubc30\uc6b0\uba74\uc11c mutable variables\ub97c \ubc30\uc6b4 \uc801\uc774 \uc5c6\ub2e4. 1 + 1 = 2\uc774\uace0 a + b = 3 \uc774\ub77c\uba74 \uadf8\ub0e5 3\uc778 \uac83\uc774\ub2e4. \uc624\ub298\uc740 a + b = 3 \uc774\uc5c8\ub294\ub370 \ub0b4\uc77c\uc740 a + b = 4\uc77c \uc21c \uc5c6\uc5c8\ub2e4. (ax^2 + bx + c \ub294 \uc5ec\ub7ec \uac12\uc774 \ub420 \uc218 \uc788\uaca0\uc9c0\ub9cc) \ud558\uc9c0\ub9cc imperative programming\uc5d0\uc11c\ub294 \uc790\uc5f0\uc2a4\ub7ec\uc6b4 \uac1c\ub150\uc774\ub2e4. int a = 1; int b = 2; a + b = 3; a = 4; a + b = 6; \uc65c \uc218\ud559\uc801\uc778 \uc6d0\uce59\uc744 \uaebc\ub0b4 \ub4e4\uc5c8\ub0d0? module\ud654 \ub54c\ubb38\uc774\ub2e4. \ud504\ub85c\uadf8\ub7a8\uc774 \ubcf5\uc7a1\ud574\uc9c0\uba74\uc11c \ubaa8\ub4c8\ud654\ub294 \ud544\uc218\uc774\ub2e4. \uc798 \ub41c \ubaa8\ub4c8\ud654\ub780 \ubb34\uc5c7\uc77c\uae4c? \ud56d\uc0c1 \ub3d9\uc77c\ud55c \uacb0\uacfc\ub97c \ub9ac\ud134\ud558\ub294 \ubaa8\ub4c8\uc77c \uac83\uc774\ub2e4. map \ud568\uc218\ub97c \uc0dd\uac01\ud574\ubcf4\uba74 \uc5b4\ub290 \ud0c0\uc785\uc5d0 \uc0c1\uad00\uc5c6\uc774 List[U]\ub97c \ub9ac\ud134\ud55c\ub2e4. \uc774\ub7f0 \uc218\ud559\uc801 \uc6d0\uce59\ub4e4\uc740 mutable variables\ub97c \uc778\uc815\ud558\uc9c0 \uc54a\ub294\ub2e4. \uadf8\ub807\uae30\uc5d0 functional programming language\uc5d0 \uc798 \ub9de\ub294\ub2e4. fp\ub294 \uc774\ub7f0 \ubaa8\ud638\ud568\uc744 \uc81c\uac70\ud568\uc73c\ub85c\uc11c \uc6d0\uce59\uc744 \ubcf4\ub2e4 \uc798 \uad6c\ud604\ud558\uace0 \ubaa8\ub4c8\ud654 \ud558\uae30 \uc88b\uc73c\uba70 multicore\uc640 cloud computing \ud658\uacbd\uc5d0\uc11c \ubcd1\ub82c\ucc98\ub9ac\ub97c \uc798 \ud560 \uc218 \uc788\uac8c \ud574\uc900\ub2e4.","title":"my summary"},{"location":"scala/Coursera/fpp-in-scala/week2/","text":"Higher order functions pass functions as arguments and retun them as results. functional languages treat functions as first-class values. = like any other value, a function can be passed as a parameter and returned as a result. provides a flexible way to compose program. Anonymous Function \ud568\uc218\ub97c parameter\ub85c \uc804\ub2ec\ud558\ub2e4\ubcf4\uba74 many small function\uc744 \ub9cc\ub4e4\uac8c \ub41c\ub2e4. \uadf8\ub807\uac8c \ub418\uba74 \uac01\uac01\uc758 naming\uc744 \uc815\ud558\ub294 \uac83\uc740 \uc5b4\ub835\uac8c \ub41c\ub2e4. => anonymous function\uc744 \uc0ac\uc6a9\ud55c\ub2e4. def str = \"abc\"; println(str) println(\"abc\") \uc704\uc5d0\ub294 str \ubcc0\uc218\ub97c \uc815\uc758\ud574\uc11c \ud638\ucd9c\ud588\uace0 \uc544\ub798\ub294 \uc815\uc758 \uc5c6\uc774 \uc0ac\uc6a9 \ud588\ub2e4. \uc774\uac83\uc774 \uac00\ub2a5\ud55c \uc774\uc720\ub294 \ubb58\uae4c? => str\uc740 literals \uc774\uae30 \ub54c\ubb38\uc774\ub2e4. \ub9c8\ucc2c\uac00\uc9c0\ub85c \uc774\ub984 \uc5c6\uc774 \ud568\uc218\ub97c \uc4f0\uba74 function literals\uac00 \ub41c\ub2e4. = anonymous functions // cube anonymous func (x: Int) => x * x * x (x: Int) \ub294 parameter x * x * x \ub294 body def sum(f: Int => Int, a: Int, b: Int): Int = { @tailrec def loop(a: Int, acc: Int): Int = { if (a > b) acc else loop(a + 1, f(a) + acc) } loop(a, 0) } def sumInts(a: Int, b: Int) = sum(x => x, a, b) def sumCubes(a: Int, b: Int) = sum(x => x * x * x, a, b) Currying \uc544\ub798 \ud568\uc218\ub97c \ub354 \uc9e7\uac8c \ud560 \uc218\ub294 \uc5c6\uc744\uae4c? def sumInts(a: Int, b: Int) = sum(x => x, a, b) def sum() def sum(f: Int => Int)(a: Int, b: Int): Int = if (a > b) 0 else f(a) + sum(f)(a + 1, b) def product(f: Int => Int)(a: Int, b: Int): Int = if (a > b) 1 else f(a) * product(f)(a + 1, b) \uc704\uc640 \uac19\uc740 \uc2a4\ud0c0\uc77c\uc758 definition\uacfc function\uc744 currying\uc774\ub77c\uace0 \ubd80\ub978\ub2e4. Haskell Brooks Curry\uc758 \uc774\ub984\uc744 \ub534 \ub124\uc774\ubc0d\uc774\ub2e4. Idea\ub294 \uadf8 \ubcf4\ub2e4 \uc804\uc778 Schonfinkel\uacfc Frege\uc5d0 \uc758\ud574\uc11c \ub098\uc654\uc9c0\ub9cc currying\uc774\ub780 \ub124\uc784\uc73c\ub85c \uad73\uc5b4\uc84c\ub2e4. Example: Finding Fixed Points A number x is called a fixed point(\uace0\uc815 \uc810) of a function f if f(x) = x \uc608\ub85c f: x => 1 + x/2 \ub77c \ud560 \ub54c fixed point\ub294 2\uc774\ub2e4. f(2) = 2\uc774\ubbc0\ub85c \uba87\uba87 \ud568\uc218\ub4e4\uc740 f\ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \uc218\ud589\ud568\uc73c\ub85c\uc11c fixed point\ub97c \ucc3e\uc744 \uc218 \uc788\ub2e4. x, f(x), f(f(x)), f(f(f(x))), ... initial estimate\ub85c \uc2dc\uc791\ud574\uc11c f\ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \uc218\ud589\ud558\ub2e4\ubcf4\uba74 \ub354 \uc774\uc0c1 \ubcc0\ud558\uc9c0 \uc54a\ub294 \uac12 \ud639\uc740 \ubcc0\uacbd\uc774 \ucda9\ubd84\ud788 \uc801\uc5b4\uc84c\uc744 \ub54c\uc758 \uac12\uc744 fixed point\ub77c \ubd80\ub97c \uc218 \uc788\ub2e4. import math.abs val tolerance = 0.0001 def isCloseEnough(x: Double, y: Double): Boolean = abs((x - y) / x) / x < tolerance def fixedPoint(f: Double => Double)(firstGuess: Double) = { @tailrec def iterate(guess: Double): Double = { val next = f(guess) if (isCloseEnough(guess, next)) next else iterate(next) } iterate(firstGuess) } fixedPoint(x => 1 + x/2)(1) // 1.9975 def sqrt(x: Double) = fixedPoint(y => x / y)(1) sqrt(2) // \ubb34\ud55c loop \uc704\uc758 \uc608\uc5d0\uc11c sqrt(2)\ub97c \uc218\ud589\ud558\uba74 \ubb34\ud55c loop\uac00 \ubc1c\uc0dd\ud55c\ub2e4. 1\uacfc 2 \ub97c \uacc4\uc18d \ubc18\ubcf5\ud55c\ub2e4 \uc774\ub97c \ud574\uacb0 \ud558\uae30 \uc704\ud574\uc11c\ub294 \uccab \ubc88\uc9f8 \uacc4\uc0b0 \uac12\uacfc \ub450 \ubc88\uc9f8 \uacc4\uc0b0 \uac12\uc758 \ud3c9\uade0\uc744 \uad6c\ud558\uba74 \ub41c\ub2e4. def sqrt(x: Double) = fixedPoint(y => (y + x / y) / 2)(1) functions as return values \uc704\uc758 \uc608\uc81c\uc5d0\uc11c \ud3c9\uade0\uc744 \ud1b5\ud574 \uc548\uc815\ud654\uc2dc\ud0a4\ub294 \uae30\uc220\uc740 \ucd94\uc0c1\ud654 \ub420 \uc218 \uc788\ub2e4. def averageDamp(f: Double => Double)(x: Double) = (x + f(x)) / 2 def sqrt3(x: Double) = fixedPoint(averageDamp(y => x / y))(1) Higher Order Function\uc774 \ud56d\uc0c1 \uc633\uc740 \uac83\uc740 \uc544\ub2c8\uba70 \uc801\uc808 \ud560 \ub54c \uc0ac\uc6a9\ud574\uc57c \ud55c\ub2e4. Functions and Data Classes class Rational(x: Int, y: Int): def numer = x def denom = y \uc704 \uc815\uc758\ub294 two entities\ub97c \uc0dd\uc131\ud55c\ub2e4. - Rational \uc774\ub77c\ub294 \uc774\ub984\uc758 new type - \uc774 type\uc758 element\ub97c \ub9cc\ub4e4\uae30 \uc704\ud55c Rational constructo \uc2a4\uce7c\ub77c\ub294 types\uacfc value\uc758 names\ub97c different namespace \uc5d0 \ubcf4\uad00\ud558\uae30 \ub54c\ubb38\uc5d0 \ucda9\ub3cc\uc744 \uac71\uc815\ud560 \ud544\uc694 \uc5c6\ub2e4. Objects elements of a class type\uc744 objects\ub77c\uace0 \ubd80\ub978\ub2e4. class \uc758 \uc0dd\uc131\uc790\ub97c calling \ud568\uc73c\ub85c\uc11c object\ub97c \ub9cc\ub4e4 \uc218 \uc788\ub2e4. Rational(1, 2) \uc544\ub798\uc640 \uac19\uc774 class\ub0b4 member\uc5d0 \uc811\uadfc \uac00\ub2a5\ud558\ub2e4 val x = Rational(1 ,2) x.numer x.denom object rationals { val x = new Rational(1, 3) val y = new Rational(5, 7) val z = new Rational(3, 2) x.add(y).mul(z) } class Rational(x: Int, y: Int) { def numer = x def denom = y def add(r: Rational) = new Rational(numer * r.denom + r.numer * denom, denom * r.denom) def mul(r: Rational) = new Rational(numer * r.numer, denom * r.denom) def neg = new Rational(-numer, denom) def sub(r: Rational) = add(r.neg) override def toString = s\"$numer/$denom\" } More Fun With Rationals Client's view\uc5d0\uc11c\ub294 \ub0b4\ubd80\uac00 \uc5b4\ub5bb\uac8c \ub3d9\uc791\ud558\ub358\uc9c0 \ub3d9\uc77c\ud558\uac8c \ubcf4\uc778\ub2e4. without affecting client\ub97c \ud558\uba74\uc11c \ub2e4\ub978 \uad6c\ud604\uc744 \uc120\ud0dd\ud558\ub294 \uac83\uc744 data abstraction \uc774\ub77c\uace0 \ud55c\ub2e4. S/E\uc5d0\uc11c\uc758 cornerstone\uc774\ub2e4. Self Reference inside of a class, this \ub294 \ud604\uc7ac \uc2e4\ud589 \uc911\uc778 method\ub0b4\uc5d0\uc11c\uc758 object\ub97c \uc758\ubbf8\ud55c\ub2e4 Preconditions require \ub85c class\uc5d0 \uc870\uac74\uc744 \ucd94\uac00\ud560 \uc218 \uc788\ub2e4. \uc870\uac74\uc5d0 \ub9de\uc9c0 \uc54a\uc73c\uba74 IllegalArgumentException\uc774 \ubc1c\uc0dd\ud558\uba70 \ucd94\uac00\ud55c \uc5d0\ub7ec \uba54\uc138\uc9c0\uac00 \ucd9c\ub825\ub41c\ub2e4. Assertions require\uc640 \ube44\uc2b7\ud55c \uc758\ubbf8\uc774\ub2e4. require\uc640 \ub3d9\uc77c\ud558\uac8c condtion\uacfc optional message string\uc744 \ubc1b\ub294\ub2e4. val x = sqrt(y) assert(x >= 0) fail\uc77c \uacbd\uc6b0 assert\ub294 require\uc640 \ub2ec\ub9ac AssertionError\ub97c \ubc1c\uc0dd\ud55c\ub2e4. require\ub294 \ud568\uc218 \ud638\ucd9c\uc790\uc5d0\uac8c precondition\uc744 \uac15\uc694\ud560 \ub54c \uc4f0\uc778\ub2e4 assert\ub294 \ud568\uc218 \uc790\uc2e0\uc774 \uccb4\ud06c \ud560 \ub54c \uc0ac\uc6a9\ud55c\ub2e4. Constructors \ubaa8\ub4e0 class\ub294 primary constructor(\uae30\ubcf8 \uc0dd\uc131\uc790)\uac00 \uc554\uc2dc\uc801\uc73c\ub85c \uc788\ub2e4. - class\uc758 \ubaa8\ub4e0 paramters\ub97c \ubc1b\uace0 - class body\uc758 \ubaa8\ub4e0 statement\ub97c \uc2e4\ud589\ud55c\ub2e4. Java \uac19\uc774 \uc5ec\ub7ec \uc0dd\uc131\uc790\ub97c \uac16\ub294 \uac83\ub3c4 \uac00\ub2a5\ud558\ub2e4. object rationals { val x = new Rational(1, 3) val y = new Rational(5, 7) val z = new Rational(3, 2) x.add(y).mul(z) y.add(y) x.less(y) x.max(y) new Rational(2) } class Rational(x: Int, y: Int) { require(y != 0, \"denominator must be nonezero\") def this(x: Int) = this(x, 1) // \uc5ec\uae30\uc5d0\uc11c\uc758 this\ub294 constructor \uc758\ubbf8\ub85c \uc4f0\uc778\ub2e4. private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) private val g = gcd(x, y) // val\ub85c \uc120\uc5b8\ud588\uae30\uc5d0 \ubc14\ub85c \ud3c9\uac00\ub418\uc11c \ub2e4\uc74c \ubd80\ud134 \uacc4\uc0b0\uc744 \uc548\ud558\uace0 \uc7ac\uc0ac\uc6a9\ud55c\ub2e4. def numer = x / g // def numer = x / gcd(x,y) // \ub9cc\uc57d \uc774\uc640 \uac19\uc774 \uc120\uc5b8 \ud558\uba74 \ub9e4\ubc88 gcd\ub97c \uacc4\uc0b0\ud574\uc57c \ud55c\ub2e4. \uacc4\uc0b0 \ub9ac\uc18c\uc2a4\uac00 \ud06c\uace0 \uac00\ub054 \ud638\ucd9c\ub420 \ub54c \uc0ac\uc6a9\ud558\uba74 \uc88b\ub2e4. def denom = y / g def less(that: Rational) = numer * that.denom < that.numer * denom def max(that: Rational) = if (this.less(that)) that else this def add(r: Rational) = new Rational(numer * r.denom + r.numer * denom, denom * r.denom) def mul(r: Rational) = new Rational(numer * r.numer, denom * r.denom) def neg = new Rational(-numer, denom) def sub(r: Rational) = add(r.neg) override def toString = s\"$numer/$denom\" } Evaluation and Operators Operators Infix Notation parameter\ub97c \uac16\ub294 \ubaa8\ub4e0 \uba54\uc18c\ub4dc\ub294 infix operaotr\ucc98\ub7fc \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. r add s r.add(s) r less s r.less(s) r max s r.max(s) Relaxed Identifiers operaotr\ub294 identifier\ub85c \uc0ac\uc6a9\ub420 \uc218 \uc788\ub2e4. - \uc601\ubb38\uc790: \ubb38\uc790\ub85c \uc2dc\uc791\ud558\uace0, \ub4a4\uc5d0\ub294 \ubb38\uc790 \ud639\uc740 \uc22b\uc790\uac00 \uc62c \uc218 \uc788\ub2e4. - Symbolic: operator symbol\ub85c \uc2dc\uc791\ud574\uc11c, \ub2e4\ub978 \uc2ec\ubcfc\uc774 \ub4a4\uc5d0 \uc62c \uc218 \uc788\ub2e4. - _ \ubb38\uc790\ub294 \ubb38\uc790\ub85c \uce74\uc6b4\ud2b8 \ub41c\ub2e4 - \uc601\ubb38\uc790 identifiers\ub294 underscore\ub85c \ub05d\ub0a0 \uc218 \uc788\uace0 \ub4a4\uc5d0 \ub2e4\ub978 operator symbols\uac00 \ubd99\uc744 \uc218 \uc788\ub2e4. * \ub9cc\uc57d \ub05d\uc774 symbol\ub4e4\ub85c \ub05d\ub098\uba74 \ub4a4\uc5d0 \ud0c0\uc785\uc744 \uc704\ud55c : \uacfc \ud55c \uce78 \ub744\uc6cc\uc57c \ud55c\ub2e4. examples - x1 - * - +?%& - vector_++ - counter_= -a \ucc98\ub7fc \ube7c\uae30\uac00 \uc544\ub2c8\ub77c \ub9c8\uc774\ub108\uc2a4 operator\ub97c \ucd94\uac00\ud558\uace0 \uc2f6\ub2e4\uba74 \uc544\ub798\uc640 \uac19\uc774 \ud574\uc57c \ud55c\ub2e4. ( unary_ \uac00 \uc55e\uc5d0 \ubd99\uc5b4\uc57c \ud558\uace0 : \uacfc \ud55c\uce78 \ub744\uc6cc \uc368\uc57c \ud55c\ub2e4.) def unary_- : Rational = new Rational(-numer, denom) Precedence Rules \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704. \uccab \ubc88\uc9f8 \ubb38\uc790\uc5d0 \ub530\ub77c \uacb0\uc815\ub41c\ub2e4. Java\ud639\uc740 C\uc640 \ucc28\uc774 \uc5c6\ub2e4. 1\ubc88\uc774 \uac00\uc7a5 \ub0ae\uc740 \uc21c\uc704\uc774\ub2e4. (all letters) | ^ & < > = ! : - / % (all other special values) class Rational(x: Int, y: Int) { require(y != 0, \"denominator must be nonezero\") def this(x: Int) = this(x, 1) // \uc5ec\uae30\uc5d0\uc11c\uc758 this\ub294 constructor \uc758\ubbf8\ub85c \uc4f0\uc778\ub2e4. private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) private val g = gcd(x, y) // val\ub85c \uc120\uc5b8\ud588\uae30\uc5d0 \ubc14\ub85c \ud3c9\uac00\ub418\uc11c \ub2e4\uc74c \ubd80\ud134 \uacc4\uc0b0\uc744 \uc548\ud558\uace0 \uc7ac\uc0ac\uc6a9\ud55c\ub2e4. def numer = x / g // def numer = x / gcd(x,y) // \ub9cc\uc57d \uc774\uc640 \uac19\uc774 \uc120\uc5b8 \ud558\uba74 \ub9e4\ubc88 gcd\ub97c \uacc4\uc0b0\ud574\uc57c \ud55c\ub2e4. \uacc4\uc0b0 \ub9ac\uc18c\uc2a4\uac00 \ud06c\uace0 \uac00\ub054 \ud638\ucd9c\ub420 \ub54c \uc0ac\uc6a9\ud558\uba74 \uc88b\ub2e4. def denom = y / g // def less(that: Rational) = numer * that.denom < that.numer * denom def < (that: Rational) = numer * that.denom < that.numer * denom def max(that: Rational) = if (this.<(that)) that else this def +(r: Rational) = new Rational(numer * r.denom + r.numer * denom, denom * r.denom) def mul(r: Rational) = new Rational(numer * r.numer, denom * r.denom) def unary_- : Rational = new Rational(-numer, denom) def -(that: Rational) = this + -that override def toString = s\"$numer/$denom\" }","title":"Higher order functions"},{"location":"scala/Coursera/fpp-in-scala/week2/#higher-order-functions","text":"pass functions as arguments and retun them as results. functional languages treat functions as first-class values. = like any other value, a function can be passed as a parameter and returned as a result. provides a flexible way to compose program.","title":"Higher order functions"},{"location":"scala/Coursera/fpp-in-scala/week2/#anonymous-function","text":"\ud568\uc218\ub97c parameter\ub85c \uc804\ub2ec\ud558\ub2e4\ubcf4\uba74 many small function\uc744 \ub9cc\ub4e4\uac8c \ub41c\ub2e4. \uadf8\ub807\uac8c \ub418\uba74 \uac01\uac01\uc758 naming\uc744 \uc815\ud558\ub294 \uac83\uc740 \uc5b4\ub835\uac8c \ub41c\ub2e4. => anonymous function\uc744 \uc0ac\uc6a9\ud55c\ub2e4. def str = \"abc\"; println(str) println(\"abc\") \uc704\uc5d0\ub294 str \ubcc0\uc218\ub97c \uc815\uc758\ud574\uc11c \ud638\ucd9c\ud588\uace0 \uc544\ub798\ub294 \uc815\uc758 \uc5c6\uc774 \uc0ac\uc6a9 \ud588\ub2e4. \uc774\uac83\uc774 \uac00\ub2a5\ud55c \uc774\uc720\ub294 \ubb58\uae4c? => str\uc740 literals \uc774\uae30 \ub54c\ubb38\uc774\ub2e4. \ub9c8\ucc2c\uac00\uc9c0\ub85c \uc774\ub984 \uc5c6\uc774 \ud568\uc218\ub97c \uc4f0\uba74 function literals\uac00 \ub41c\ub2e4. = anonymous functions // cube anonymous func (x: Int) => x * x * x (x: Int) \ub294 parameter x * x * x \ub294 body def sum(f: Int => Int, a: Int, b: Int): Int = { @tailrec def loop(a: Int, acc: Int): Int = { if (a > b) acc else loop(a + 1, f(a) + acc) } loop(a, 0) } def sumInts(a: Int, b: Int) = sum(x => x, a, b) def sumCubes(a: Int, b: Int) = sum(x => x * x * x, a, b)","title":"Anonymous Function"},{"location":"scala/Coursera/fpp-in-scala/week2/#currying","text":"\uc544\ub798 \ud568\uc218\ub97c \ub354 \uc9e7\uac8c \ud560 \uc218\ub294 \uc5c6\uc744\uae4c? def sumInts(a: Int, b: Int) = sum(x => x, a, b) def sum() def sum(f: Int => Int)(a: Int, b: Int): Int = if (a > b) 0 else f(a) + sum(f)(a + 1, b) def product(f: Int => Int)(a: Int, b: Int): Int = if (a > b) 1 else f(a) * product(f)(a + 1, b) \uc704\uc640 \uac19\uc740 \uc2a4\ud0c0\uc77c\uc758 definition\uacfc function\uc744 currying\uc774\ub77c\uace0 \ubd80\ub978\ub2e4. Haskell Brooks Curry\uc758 \uc774\ub984\uc744 \ub534 \ub124\uc774\ubc0d\uc774\ub2e4. Idea\ub294 \uadf8 \ubcf4\ub2e4 \uc804\uc778 Schonfinkel\uacfc Frege\uc5d0 \uc758\ud574\uc11c \ub098\uc654\uc9c0\ub9cc currying\uc774\ub780 \ub124\uc784\uc73c\ub85c \uad73\uc5b4\uc84c\ub2e4.","title":"Currying"},{"location":"scala/Coursera/fpp-in-scala/week2/#example-finding-fixed-points","text":"A number x is called a fixed point(\uace0\uc815 \uc810) of a function f if f(x) = x \uc608\ub85c f: x => 1 + x/2 \ub77c \ud560 \ub54c fixed point\ub294 2\uc774\ub2e4. f(2) = 2\uc774\ubbc0\ub85c \uba87\uba87 \ud568\uc218\ub4e4\uc740 f\ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \uc218\ud589\ud568\uc73c\ub85c\uc11c fixed point\ub97c \ucc3e\uc744 \uc218 \uc788\ub2e4. x, f(x), f(f(x)), f(f(f(x))), ... initial estimate\ub85c \uc2dc\uc791\ud574\uc11c f\ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \uc218\ud589\ud558\ub2e4\ubcf4\uba74 \ub354 \uc774\uc0c1 \ubcc0\ud558\uc9c0 \uc54a\ub294 \uac12 \ud639\uc740 \ubcc0\uacbd\uc774 \ucda9\ubd84\ud788 \uc801\uc5b4\uc84c\uc744 \ub54c\uc758 \uac12\uc744 fixed point\ub77c \ubd80\ub97c \uc218 \uc788\ub2e4. import math.abs val tolerance = 0.0001 def isCloseEnough(x: Double, y: Double): Boolean = abs((x - y) / x) / x < tolerance def fixedPoint(f: Double => Double)(firstGuess: Double) = { @tailrec def iterate(guess: Double): Double = { val next = f(guess) if (isCloseEnough(guess, next)) next else iterate(next) } iterate(firstGuess) } fixedPoint(x => 1 + x/2)(1) // 1.9975 def sqrt(x: Double) = fixedPoint(y => x / y)(1) sqrt(2) // \ubb34\ud55c loop \uc704\uc758 \uc608\uc5d0\uc11c sqrt(2)\ub97c \uc218\ud589\ud558\uba74 \ubb34\ud55c loop\uac00 \ubc1c\uc0dd\ud55c\ub2e4. 1\uacfc 2 \ub97c \uacc4\uc18d \ubc18\ubcf5\ud55c\ub2e4 \uc774\ub97c \ud574\uacb0 \ud558\uae30 \uc704\ud574\uc11c\ub294 \uccab \ubc88\uc9f8 \uacc4\uc0b0 \uac12\uacfc \ub450 \ubc88\uc9f8 \uacc4\uc0b0 \uac12\uc758 \ud3c9\uade0\uc744 \uad6c\ud558\uba74 \ub41c\ub2e4. def sqrt(x: Double) = fixedPoint(y => (y + x / y) / 2)(1)","title":"Example: Finding Fixed Points"},{"location":"scala/Coursera/fpp-in-scala/week2/#functions-as-return-values","text":"\uc704\uc758 \uc608\uc81c\uc5d0\uc11c \ud3c9\uade0\uc744 \ud1b5\ud574 \uc548\uc815\ud654\uc2dc\ud0a4\ub294 \uae30\uc220\uc740 \ucd94\uc0c1\ud654 \ub420 \uc218 \uc788\ub2e4. def averageDamp(f: Double => Double)(x: Double) = (x + f(x)) / 2 def sqrt3(x: Double) = fixedPoint(averageDamp(y => x / y))(1) Higher Order Function\uc774 \ud56d\uc0c1 \uc633\uc740 \uac83\uc740 \uc544\ub2c8\uba70 \uc801\uc808 \ud560 \ub54c \uc0ac\uc6a9\ud574\uc57c \ud55c\ub2e4.","title":"functions as return values"},{"location":"scala/Coursera/fpp-in-scala/week2/#functions-and-data","text":"","title":"Functions and Data"},{"location":"scala/Coursera/fpp-in-scala/week2/#classes","text":"class Rational(x: Int, y: Int): def numer = x def denom = y \uc704 \uc815\uc758\ub294 two entities\ub97c \uc0dd\uc131\ud55c\ub2e4. - Rational \uc774\ub77c\ub294 \uc774\ub984\uc758 new type - \uc774 type\uc758 element\ub97c \ub9cc\ub4e4\uae30 \uc704\ud55c Rational constructo \uc2a4\uce7c\ub77c\ub294 types\uacfc value\uc758 names\ub97c different namespace \uc5d0 \ubcf4\uad00\ud558\uae30 \ub54c\ubb38\uc5d0 \ucda9\ub3cc\uc744 \uac71\uc815\ud560 \ud544\uc694 \uc5c6\ub2e4.","title":"Classes"},{"location":"scala/Coursera/fpp-in-scala/week2/#objects","text":"elements of a class type\uc744 objects\ub77c\uace0 \ubd80\ub978\ub2e4. class \uc758 \uc0dd\uc131\uc790\ub97c calling \ud568\uc73c\ub85c\uc11c object\ub97c \ub9cc\ub4e4 \uc218 \uc788\ub2e4. Rational(1, 2) \uc544\ub798\uc640 \uac19\uc774 class\ub0b4 member\uc5d0 \uc811\uadfc \uac00\ub2a5\ud558\ub2e4 val x = Rational(1 ,2) x.numer x.denom object rationals { val x = new Rational(1, 3) val y = new Rational(5, 7) val z = new Rational(3, 2) x.add(y).mul(z) } class Rational(x: Int, y: Int) { def numer = x def denom = y def add(r: Rational) = new Rational(numer * r.denom + r.numer * denom, denom * r.denom) def mul(r: Rational) = new Rational(numer * r.numer, denom * r.denom) def neg = new Rational(-numer, denom) def sub(r: Rational) = add(r.neg) override def toString = s\"$numer/$denom\" }","title":"Objects"},{"location":"scala/Coursera/fpp-in-scala/week2/#more-fun-with-rationals","text":"Client's view\uc5d0\uc11c\ub294 \ub0b4\ubd80\uac00 \uc5b4\ub5bb\uac8c \ub3d9\uc791\ud558\ub358\uc9c0 \ub3d9\uc77c\ud558\uac8c \ubcf4\uc778\ub2e4. without affecting client\ub97c \ud558\uba74\uc11c \ub2e4\ub978 \uad6c\ud604\uc744 \uc120\ud0dd\ud558\ub294 \uac83\uc744 data abstraction \uc774\ub77c\uace0 \ud55c\ub2e4. S/E\uc5d0\uc11c\uc758 cornerstone\uc774\ub2e4.","title":"More Fun With Rationals"},{"location":"scala/Coursera/fpp-in-scala/week2/#self-reference","text":"inside of a class, this \ub294 \ud604\uc7ac \uc2e4\ud589 \uc911\uc778 method\ub0b4\uc5d0\uc11c\uc758 object\ub97c \uc758\ubbf8\ud55c\ub2e4","title":"Self Reference"},{"location":"scala/Coursera/fpp-in-scala/week2/#preconditions","text":"require \ub85c class\uc5d0 \uc870\uac74\uc744 \ucd94\uac00\ud560 \uc218 \uc788\ub2e4. \uc870\uac74\uc5d0 \ub9de\uc9c0 \uc54a\uc73c\uba74 IllegalArgumentException\uc774 \ubc1c\uc0dd\ud558\uba70 \ucd94\uac00\ud55c \uc5d0\ub7ec \uba54\uc138\uc9c0\uac00 \ucd9c\ub825\ub41c\ub2e4.","title":"Preconditions"},{"location":"scala/Coursera/fpp-in-scala/week2/#assertions","text":"require\uc640 \ube44\uc2b7\ud55c \uc758\ubbf8\uc774\ub2e4. require\uc640 \ub3d9\uc77c\ud558\uac8c condtion\uacfc optional message string\uc744 \ubc1b\ub294\ub2e4. val x = sqrt(y) assert(x >= 0) fail\uc77c \uacbd\uc6b0 assert\ub294 require\uc640 \ub2ec\ub9ac AssertionError\ub97c \ubc1c\uc0dd\ud55c\ub2e4. require\ub294 \ud568\uc218 \ud638\ucd9c\uc790\uc5d0\uac8c precondition\uc744 \uac15\uc694\ud560 \ub54c \uc4f0\uc778\ub2e4 assert\ub294 \ud568\uc218 \uc790\uc2e0\uc774 \uccb4\ud06c \ud560 \ub54c \uc0ac\uc6a9\ud55c\ub2e4.","title":"Assertions"},{"location":"scala/Coursera/fpp-in-scala/week2/#constructors","text":"\ubaa8\ub4e0 class\ub294 primary constructor(\uae30\ubcf8 \uc0dd\uc131\uc790)\uac00 \uc554\uc2dc\uc801\uc73c\ub85c \uc788\ub2e4. - class\uc758 \ubaa8\ub4e0 paramters\ub97c \ubc1b\uace0 - class body\uc758 \ubaa8\ub4e0 statement\ub97c \uc2e4\ud589\ud55c\ub2e4. Java \uac19\uc774 \uc5ec\ub7ec \uc0dd\uc131\uc790\ub97c \uac16\ub294 \uac83\ub3c4 \uac00\ub2a5\ud558\ub2e4. object rationals { val x = new Rational(1, 3) val y = new Rational(5, 7) val z = new Rational(3, 2) x.add(y).mul(z) y.add(y) x.less(y) x.max(y) new Rational(2) } class Rational(x: Int, y: Int) { require(y != 0, \"denominator must be nonezero\") def this(x: Int) = this(x, 1) // \uc5ec\uae30\uc5d0\uc11c\uc758 this\ub294 constructor \uc758\ubbf8\ub85c \uc4f0\uc778\ub2e4. private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) private val g = gcd(x, y) // val\ub85c \uc120\uc5b8\ud588\uae30\uc5d0 \ubc14\ub85c \ud3c9\uac00\ub418\uc11c \ub2e4\uc74c \ubd80\ud134 \uacc4\uc0b0\uc744 \uc548\ud558\uace0 \uc7ac\uc0ac\uc6a9\ud55c\ub2e4. def numer = x / g // def numer = x / gcd(x,y) // \ub9cc\uc57d \uc774\uc640 \uac19\uc774 \uc120\uc5b8 \ud558\uba74 \ub9e4\ubc88 gcd\ub97c \uacc4\uc0b0\ud574\uc57c \ud55c\ub2e4. \uacc4\uc0b0 \ub9ac\uc18c\uc2a4\uac00 \ud06c\uace0 \uac00\ub054 \ud638\ucd9c\ub420 \ub54c \uc0ac\uc6a9\ud558\uba74 \uc88b\ub2e4. def denom = y / g def less(that: Rational) = numer * that.denom < that.numer * denom def max(that: Rational) = if (this.less(that)) that else this def add(r: Rational) = new Rational(numer * r.denom + r.numer * denom, denom * r.denom) def mul(r: Rational) = new Rational(numer * r.numer, denom * r.denom) def neg = new Rational(-numer, denom) def sub(r: Rational) = add(r.neg) override def toString = s\"$numer/$denom\" }","title":"Constructors"},{"location":"scala/Coursera/fpp-in-scala/week2/#evaluation-and-operators","text":"","title":"Evaluation and Operators"},{"location":"scala/Coursera/fpp-in-scala/week2/#operators","text":"","title":"Operators"},{"location":"scala/Coursera/fpp-in-scala/week2/#infix-notation","text":"parameter\ub97c \uac16\ub294 \ubaa8\ub4e0 \uba54\uc18c\ub4dc\ub294 infix operaotr\ucc98\ub7fc \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. r add s r.add(s) r less s r.less(s) r max s r.max(s)","title":"Infix Notation"},{"location":"scala/Coursera/fpp-in-scala/week2/#relaxed-identifiers","text":"operaotr\ub294 identifier\ub85c \uc0ac\uc6a9\ub420 \uc218 \uc788\ub2e4. - \uc601\ubb38\uc790: \ubb38\uc790\ub85c \uc2dc\uc791\ud558\uace0, \ub4a4\uc5d0\ub294 \ubb38\uc790 \ud639\uc740 \uc22b\uc790\uac00 \uc62c \uc218 \uc788\ub2e4. - Symbolic: operator symbol\ub85c \uc2dc\uc791\ud574\uc11c, \ub2e4\ub978 \uc2ec\ubcfc\uc774 \ub4a4\uc5d0 \uc62c \uc218 \uc788\ub2e4. - _ \ubb38\uc790\ub294 \ubb38\uc790\ub85c \uce74\uc6b4\ud2b8 \ub41c\ub2e4 - \uc601\ubb38\uc790 identifiers\ub294 underscore\ub85c \ub05d\ub0a0 \uc218 \uc788\uace0 \ub4a4\uc5d0 \ub2e4\ub978 operator symbols\uac00 \ubd99\uc744 \uc218 \uc788\ub2e4. * \ub9cc\uc57d \ub05d\uc774 symbol\ub4e4\ub85c \ub05d\ub098\uba74 \ub4a4\uc5d0 \ud0c0\uc785\uc744 \uc704\ud55c : \uacfc \ud55c \uce78 \ub744\uc6cc\uc57c \ud55c\ub2e4. examples - x1 - * - +?%& - vector_++ - counter_= -a \ucc98\ub7fc \ube7c\uae30\uac00 \uc544\ub2c8\ub77c \ub9c8\uc774\ub108\uc2a4 operator\ub97c \ucd94\uac00\ud558\uace0 \uc2f6\ub2e4\uba74 \uc544\ub798\uc640 \uac19\uc774 \ud574\uc57c \ud55c\ub2e4. ( unary_ \uac00 \uc55e\uc5d0 \ubd99\uc5b4\uc57c \ud558\uace0 : \uacfc \ud55c\uce78 \ub744\uc6cc \uc368\uc57c \ud55c\ub2e4.) def unary_- : Rational = new Rational(-numer, denom)","title":"Relaxed Identifiers"},{"location":"scala/Coursera/fpp-in-scala/week2/#precedence-rules","text":"\uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704. \uccab \ubc88\uc9f8 \ubb38\uc790\uc5d0 \ub530\ub77c \uacb0\uc815\ub41c\ub2e4. Java\ud639\uc740 C\uc640 \ucc28\uc774 \uc5c6\ub2e4. 1\ubc88\uc774 \uac00\uc7a5 \ub0ae\uc740 \uc21c\uc704\uc774\ub2e4. (all letters) | ^ & < > = ! : - / % (all other special values) class Rational(x: Int, y: Int) { require(y != 0, \"denominator must be nonezero\") def this(x: Int) = this(x, 1) // \uc5ec\uae30\uc5d0\uc11c\uc758 this\ub294 constructor \uc758\ubbf8\ub85c \uc4f0\uc778\ub2e4. private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) private val g = gcd(x, y) // val\ub85c \uc120\uc5b8\ud588\uae30\uc5d0 \ubc14\ub85c \ud3c9\uac00\ub418\uc11c \ub2e4\uc74c \ubd80\ud134 \uacc4\uc0b0\uc744 \uc548\ud558\uace0 \uc7ac\uc0ac\uc6a9\ud55c\ub2e4. def numer = x / g // def numer = x / gcd(x,y) // \ub9cc\uc57d \uc774\uc640 \uac19\uc774 \uc120\uc5b8 \ud558\uba74 \ub9e4\ubc88 gcd\ub97c \uacc4\uc0b0\ud574\uc57c \ud55c\ub2e4. \uacc4\uc0b0 \ub9ac\uc18c\uc2a4\uac00 \ud06c\uace0 \uac00\ub054 \ud638\ucd9c\ub420 \ub54c \uc0ac\uc6a9\ud558\uba74 \uc88b\ub2e4. def denom = y / g // def less(that: Rational) = numer * that.denom < that.numer * denom def < (that: Rational) = numer * that.denom < that.numer * denom def max(that: Rational) = if (this.<(that)) that else this def +(r: Rational) = new Rational(numer * r.denom + r.numer * denom, denom * r.denom) def mul(r: Rational) = new Rational(numer * r.numer, denom * r.denom) def unary_- : Rational = new Rational(-numer, denom) def -(that: Rational) = this + -that override def toString = s\"$numer/$denom\" }","title":"Precedence Rules"}]}