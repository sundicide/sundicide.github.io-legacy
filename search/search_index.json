{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"scala/","text":"Welcome","title":"Welcome"},{"location":"scala/#welcome","text":"","title":"Welcome"},{"location":"scala/Coursera/","text":"dd","title":"Index"},{"location":"scala/Coursera/fpd-in-scala/","text":"sss","title":"Index"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/","text":"Week3-1: Type-Directed Programming \uc9c0\uae08\uae4c\uc9c0 \ubd24\ub4ef\uc774 compiler\ub294 values\ub85c \ubd80\ud130 types\uc744 \uc720\ucd94\ud560 \uc218 \uc788\ub2e4. val x = 12 compiler\ub294 x\ub97c Int\ub85c \uc720\ucd94\ud55c\ub2e4. \uc65c\ub0d0\ud558\uba74 \uac12\uc774 12\uc774\ubbc0\ub85c \uc544\ub798\uc640 \uac19\uc774 \ubcf5\uc7a1\ud55c \ud45c\ud604\uc5d0\uc11c\ub3c4 \uc774\ub294 \uc801\uc6a9\ub41c\ub2e4. val y = x + 3 compiler\ub294 y \ub610\ud55c Int\ub85c \uc720\ucd94\ud55c\ub2e4. \uc774\ubc88\uc5d0\ub294 \ubc18\ub300\ub85c compiler\uac00 types\ub85c \ubd80\ud130 values\ub97c \uc720\ucd94\ud558\ub294 \uacfc\uc815\uc744 \ubcfc \uac83\uc774\ub2e4. \uc65c \uc774\uac83\uc774 \uc720\uc6a9\ud558\ub0d0? \ud655\uc2e4\ud55c \ud558\ub098\ub294 compiler\uac00 value\ub97c \ucc3e\uc544\uc11c \uc904 \uc218 \uc788\uae30 \ub54c\ubb38\uc774\ub2e4. \uc774\ubc88 \ub808\uc2a8\uc758 \ub098\uba38\uc9c0\ub294 \uc774\ub7f0 \uba54\uce74\ub2c8\uc998\uc758 motivation\uc744 \uc18c\uac1c\ud558\uace0 \ub2e4\uc74c \ubc88 \ub808\uc2a8\uc740 how to use it\uc744 \uc124\uba85\ud560 \uac83\uc774\ub2e4. Motivating Example parameter\ub85c List[Int]\ub97c \ubc1b\uc544\uc11c \uc815\ub82c\ud55c \uacb0\uacfc\ub97c List[Int]\ub85c \ub9ac\ud134\ud558\ub294 \ud568\uc218\ub97c \uc0dd\uac01\ud574\ubcf4\uc790. def sort(xs: List[Int]): List[Int] = { ... ... if (x < y) ... ... } \uc0c1\uc138 \ucf54\ub4dc\ub294 \uc5ec\uae30\uc5d0\uc11c \ud544\uc694\uac00 \uc5c6\uae30\uc5d0 \uc0dd\ub7b5\ud588\ub2e4. \uc704 \ucf54\ub4dc\ub294 Int\uc5d0 \ub300\ud574\uc11c\ub9cc \uc801\uc6a9 \uac00\ub2a5\ud558\ubbc0\ub85c general\ud558\uac8c \ubaa8\ub4e0 \ud0c0\uc785\uc5d0 \ub300\ud574\uc11c\ub3c4 \ub3d9\uc791\ud558\uac8c \ud558\uace0 \uc2f6\ub2e4. \uc774\uc5d0 \ub300\ud55c straightforward approach\ub294 polymorphic type\uc744 \uc0ac\uc6a9\ud558\ub294 \uac83\uc774\ub2e4. def sort[A](xs: List[A]): List[A] = ... \ud558\uc9c0\ub9cc \uc774\uac83\ub9cc\uc73c\ub85c\ub294 \ubd80\uc871\ud558\ub2e4. \uc65c\ub0d0\ud558\uba74 \uac01 type\ubcc4\ub85c compare\ub97c \ub2e4\ub974\uac8c \ud574\uc57c \ud558\uae30 \ub54c\ubb38\uc774\ub2e4. \uadf8\ub798\uc11c \uc774\ubc88\uc5d4 \uac01 compare \ud568\uc218\ub97c parameter\ub85c \ubc1b\ub3c4\ub85d \ud574\ubcf4\uc790. def sort[A](xs: List[A])(lessThan: (A, A) => Boolean): List[A] = { ... ... if (lessThan(x, y)) ... ... } \uadf8\ub807\uac8c \ub418\uba74 \uc544\ub798\uc640 \uac19\uc774 \uac00\ub2a5\ud558\ub2e4' val xs = List(-5, 6, 3, 2, 7) val strings = List(\"apple\", \"pear\", \"orange\", \"pineapple\") sort(xs)((x, y) => x < y) sort(strings)((s1, s2) => s1.compareTo(s2) < 0) Refactoring With Ordering scala\ub294 standard library \uc5d0\uc11c comparing \ud558\ub294 \ud568\uc218\ub97c \uae30\ubcf8\uc73c\ub85c \uc81c\uacf5\ud55c\ub2e4. package scala.math trait Ordering[A] { def compare(a1: A, a2: A): Int def lt(a1: A, a2: A): Boolean = compare(a1, a2) <= 0 ... } compare \ud568\uc218\ub294 2\uac1c\uc758 parameter\ub97c \ubc1b\uc544\uc11c \uccab \ubc88\uc9f8 \uac12\uc774 \ud074 \uacbd\uc6b0 \uc591\uc218, \uc791\uc744 \uacbd\uc6b0 \uc74c\uc218, \ub3d9\uc77c\ud55c \uacbd\uc6b0 0\uc744 \ub9ac\ud134\ud55c\ub2e4. \uc774\ub97c \uc0ac\uc6a9\ud558\uba74 \uc544\ub798\uc640 \uac19\uc774 \ubcc0\uacbd \uac00\ub2a5\ud558\ub2e4. def sort[A](xs: List[A])(ord: Ordering[A]): List[A] = { ... ... if (ord.lt(x, y)) ... ... } import scala.math.Ordering sort(xs)(Ordering.Int) sort(strings)(Ordering.String) \uc5ec\uae30\uc5d0\uc11c \uc0ac\uc6a9 \uc911\uc778 Int\uc640 String\uc740 types \uc774 \uc544\ub2c8\uace0 values \uc784\uc744 \uc54c\uc544\uc57c \ud55c\ub2e4. scala\uc5d0\uc11c\ub294 types\uacfc values\uc5d0 \ub3d9\uc77c\ud55c symbol\uc744 \uc0ac\uc6a9\ud558\ub294 \uac83\uc774 \uac00\ub2a5\ud558\ub2e4. object Ordering { val Int = new Ordering[Int] { def compare(x: Int, y: Int) = if (x > y) 1 else if (x < y) -1 else 0 } } Reducing Boilerplate \uc9c0\uae08\uae4c\uc9c0 \uc815\uc758\ud55c \uac83\uc744 \ub530\ub974\uba74 \uc798 \ub3d9\uc791\ud55c\ub2e4. \ud558\uc9c0\ub9cc \ubaa8\ub4e0 \uacbd\uc6b0\uc5d0 \ub300\ud574 boilerplate\uac00 \uc874\uc7ac\ud558\uac8c \ub41c\ub2e4. Int\ub97c \ube44\uad50\ud560 \ub54c\ub9c8\ub2e4 Ordering.Int \ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \uc0ac\uc6a9\ud574\uc57c \ud55c\ub2e4. sort(xs)(Ordering.Int) sort(ys)(Ordering.Int) sort(strings)(Ordering.String) Implicit Parameters implicit \uc744 \uba85\uc2dc\ud568\uc73c\ub85c\uc11c compiler\uac00 argument ord \ub97c support\ub97c \ud558\uac8c \ud560 \uc218 \uc788\ub2e4. def sort[A](xs: List[A])(implicit ord: Ordering[A]): List[A] = ... sort(xs) sort(ys) sort(strings) \uc704\uc640 \uac19\uc774 \ud558\uba74 \ucef4\ud30c\uc77c\ub7ec\uac00 value\uc5d0 \ub9de\ucdb0 type\uc744 \uacb0\uc815\ud55c\ub2e4. \ucef4\ud30c\uc77c\ub7ec\uac00 \uc218\ud589\ud558\ub294 \uacfc\uc815\uc744 \uc790\uc138\ud788 \uc0b4\ud3b4\ubcf4\uc790. sort(xs) xs \uac00 List[Int] \ud0c0\uc785\uc774\ubbc0\ub85c \ucef4\ud30c\uc77c\ub7ec\ub294 \uc704\uc758 \ucf54\ub4dc\ub97c \uc544\ub798\uc640 \uac19\uc774 \ubcc0\ud658\ud55c\ub2e4. sort[Int](xs) \uadf8\ub9ac\uace0 \ucef4\ud30c\uc77c\ub7ec\ub294 candidate definition\uc911 Ordering[Int] \ud0c0\uc785\uc5d0 \ub9de\ub294 \uac83\uc744 \ucc3e\ub294\ub2e4. \uc704\uc758 \ucf00\uc774\uc2a4\uc5d0\uc11c\ub294 Ordering.Int\uc640 only matching\ub418\uace0 \ucef4\ud30c\uc77c\ub7ec\ub294 method sort\ub85c \uc774\ub97c \uc804\ub2ec\ud55c\ub2e4. sort[Int](xs)(Ordering.Int) candidate values\uac00 \uc5b4\ub5bb\uac8c \uc815\uc758\ub3c4\uc5b4\uc788\ub294 \uc9c0\ub97c \uc0b4\ud3b4 \ubcf4\uae30 \uc804\uc5d0 implicit \ud0a4\uc6cc\ub4dc\uc5d0 \ub300\ud574 \uc790\uc138\ud788 \uc54c\uc544\ubcf4\uc790. method\ub294 \uc624\uc9c1 \ud558\ub098\uc758 implicit parameter list\ub97c \uac00\uc9c8 \uc218 \uc788\uc73c\uba70 \uc774\ub294 \ub9c8\uc9c0\ub9c9 paramter\uac00 \ub418\uc57c \ud55c\ub2e4. At call site, the arguments of the given clause are usually left out, although it is possible to explicitly pass them: // Argument inferred by the compiler sort(xs) // Explicit argument sort(xs)(Ordering.Int.reverse) Candidates for Implicit Parameters \ucef4\ud30c\uc77c\ub7ec\uac00 type T\uc5d0 \ub300\ud574 \uc5b4\ub5a4 candidate definition\ub97c \ucc3e\uc744\uae4c? \ucef4\ud30c\uc77c\ub7ec\ub294 \uc544\ub798 definition\uc744 \ucc3e\ub294\ub2e4. have type T, are marked implicit, are visible at the point of the function call, or are defined in a companion object associated with T. most specific\ud55c \uc815\uc758\ub97c \ucc3e\uac8c \ub418\uba74 \uadf8\uac83\uc744 \uc0ac\uc6a9\ud558\uace0 \uc5c6\ub2e4\uba74 error\ub97c report\ud55c\ub2e4. implicit Definition implicit definition\uc774\ub780 implicit \ud0a4\uc6cc\ub4dc\uc640 \ud568\uaed8 \uc815\uc758\ub41c \uac83\uc744 \ub9d0\ud55c\ub2e4. object Ordering { implicit val Int: Ordering[Int] = ... } \uc704\uc758 \ucf54\ub4dc\ub294 Int\ub77c\ub294 \uc774\ub984\uc744 \uac00\uc9c4 Ordering[Int] \ud0c0\uc785\uc758 implicit value\ub97c \uc815\uc758\ud55c \uac83\uc774\ub2e4. Any val, lazy val, def, or object definition can be marked implicit. \ub9c8\uc9c0\ub9c9\uc73c\ub85c implicit definitions\ub294 type parameters\uc640 implicit parameters\ub97c \uac00\uc9c8 \uc218 \uc788\ub2e4. implicit def orderingPair[A, B](implicit orderingA: Ordering[A], orderingB: Ordering[B] ): Ordering[(A, B)] = ... Implicit Search Scope type T\uc758 implicit value\ub97c \ucc3e\uae30 \uc704\ud574 \uccab \ubc88\uc9f8\ub85c visible(inherited, imported, or defined in an enclosing scope)\ud55c \ubaa8\ub4e0 implicit definitions\ub97c \ucc3e\ub294\ub2e4. \ub9cc\uc57d \ucef4\ud30c\uc77c\ub7ec\uac00 lexcial scope\uc5d0\uc11c implicit instance\uc640 \ub9e4\uce6d\ub418\ub294 type T\ub97c \ucc3e\uc9c0 \ubabb\ud558\uba74, T\uc640 \uad00\ub828\ub41c companion objects\uc5d0\uc11c \uc774\uc5b4\uc11c \ucc3e\ub294\ub2e4. (companion objects\uc640 types\ub294 other types\uc640 \uc5f0\uad00\uc788\ub2e4.) A companion object is an object that has the same name as a type. \uc608\ub85c object scala.math.Ordering is the companion of the type scala.math.Ordering. The types associated with a type T are: if T has parent types T\u2081 with T\u2082 ... with T\u2099, the union of the parts of T\u2081, ... T\u2099 as well as T itself, if T is a parameterized type S[T\u2081, T\u2082, ..., T\u2099], the union of the parts of S and T\u2081, ..., T\u2099, otherwise, just T itself. As an example, consider the following type hierarchy: trait Foo[A] trait Bar[A] extends Foo[A] trait Baz[A] extends Bar[A] trait X trait Y extends X \ub9cc\uc57d Bar[Y] \ud0c0\uc785\uc758 implicit value\uac00 \ud544\uc694\ud558\ub2e4\uba74 compiler\ub294 \uc544\ub798\uc640 \uac19\uc740 companion object\uc5d0\uc11c implicit definition\uc744 \ucc3e\uc744 \uac83\uc774\ub2e4. Bar, because it is a part of Bar[Y], Y, because it is a part of Bar[Y], Foo, because it is a parent type of Bar, and X, because it is a parent type of Y. However, the Baz companion object will not be visited. Implicit Search Process search process\ub294 no candidate found \ud639\uc740 \ub9e4\uce6d\ub418\ub294 \ucd5c\uc18c\ud55c \ud558\ub098\uc758 candidate\ub97c \uacb0\uacfc\ub97c \ub9cc\ub4e4\uc5b4 \ub0b8\ub2e4. \ub9cc\uc57d no no available implicit definition matching \uc774\ub77c\uba74 \uc5d0\ub7ec\uac00 repot \ub41c\ub2e4. scala> def f(implicit n: Int) = () scala> f ^ error: could not find implicit value for parameter n: Int \ubc18\ub300\ub85c \ub458 \uc774\uc0c1\uc758 implicit definition\uc774 eligibale \ud558\ub2e4\uba74 ambiguity\uac00 report \ub41c\ub2e4. scala> implicit val x: Int = 0 scala> implicit val y: Int = 1 scala> def f(implicit n: Int) = () scala> f ^ error: ambiguous implicit values: both value x of type => Int same type\uc5d0 \ub9e4\uce6d\ub418\ub294 several implicit definitions\uac00 \uc788\uc5b4\ub3c4 \ud558\ub098\ub97c \ud2b9\uc815 \ud560 \uc218 \uc788\ub2e4\uba74 \uad1c\ucc2e\ub2e4. A definition a: A is more specific than a definition b: B if: type A has more \u201cfixed\u201d parts, or, a is defined in a class or object which is a subclass of the class defining b. Let\u2019s see a few examples of priorities at work. Which implicit definition matches the Int implicit parameter when the following method f is called? implicit def universal[A]: A = ??? implicit def int: Int = ??? def f(implicit n: Int) = () f \uc704\uc758 \uacbd\uc6b0\uc5d0\uc11c universal\uc740 type paramter\ub97c \uc9c0\ub2c8\uace0 int\ub294 \uc544\ub2c8\uae30\uc5d0, int\uac00 more fixed parts\ub97c \uac16\uace0 \uc774\ub294 universal\ubcf4\ub2e4 \uba3c\uc800 \uace0\ub824\ub41c\ub2e4. \uadf8\ub807\uae30 \ub54c\ubb38\uc5d0 \ucef4\ud30c\uc77c\ub7ec\uac00 int\ub97c \uc120\ud0dd\ud568\uc5d0 \uc788\uc5b4 ambiguity\uac00 \uc5c6\ub2e4. \uc544\ub798\uc640 \uac19\uc774 \uc788\uc744 \ub54c implicit Int \ud30c\ub77c\ubbf8\ud130\ub97c \uac16\ub294 f method\ub294 \uc5b4\ub290 implicit definition\uc5d0 \ub9e4\uce58 \ub420\uae4c? trait A { implicit val x: Int = 0 } trait B extends A { implicit val y: Int = 1 def f(implicit n: Int) = () f } y\uac00 A\ub97c extend\ud558\ub294 trait\uc774\ubbc0\ub85c y\uac00 A\ubcf4\ub2e4 more specific \ud558\ub2e4. \uadf8\ub7ec\ubbc0\ub85c \ucef4\ud30c\uc77c\ub7ec\uac00 y\ub97c \uc120\ud0dd\ud558\ub294 \uac83\uc5d0 ambiguity\ub294 \uc5c6\ub2e4. Context Bounds Syntactic sugar allows the omission of the implicit parameter list: def printSorted[A: Ordering](as: List[A]): Unit = { println(sort(as)) } Type parameter A has one context bound: Ordering. This is equivalent to writing: def printSorted[A](as: List[A])(implicit ev1: Ordering[A]): Unit = { println(sort(as)) } More generally, a method definition such as: def f[A: U\u2081 ... : U\u2099](ps): R = ... Is expanded to: def f[A](ps)(implicit ev\u2081: U\u2081[A], ..., ev\u2099: U\u2099[A]): R = ... Implicit Query At any point in a program, one can query an implicit value of a given type by calling the implicitly operation: scala> implicitly[Ordering[Int]] res0: Ordering[Int] = scala.math.Ordering$Int$@73564ab0 Note that implicitly is not a special keyword, it is defined as a library operation: def implicitly[A](implicit value: A): A = value Summary In this lesson we have introduced the concept of type-directed programming, a language mechanism that infers values from types. There has to be a unique (most specific) implicit definition matching the queried type for it to be selected by the compiler. Implicit values are searched in the enclosing lexical scope (imports, parameters, inherited members) as well as in the implicit scope of the queried type. The implicit scope of type is made of implicit values defined in companion objects of types associated with the queried type.","title":"Week3-1: Type-Directed Programming"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#week3-1-type-directed-programming","text":"\uc9c0\uae08\uae4c\uc9c0 \ubd24\ub4ef\uc774 compiler\ub294 values\ub85c \ubd80\ud130 types\uc744 \uc720\ucd94\ud560 \uc218 \uc788\ub2e4. val x = 12 compiler\ub294 x\ub97c Int\ub85c \uc720\ucd94\ud55c\ub2e4. \uc65c\ub0d0\ud558\uba74 \uac12\uc774 12\uc774\ubbc0\ub85c \uc544\ub798\uc640 \uac19\uc774 \ubcf5\uc7a1\ud55c \ud45c\ud604\uc5d0\uc11c\ub3c4 \uc774\ub294 \uc801\uc6a9\ub41c\ub2e4. val y = x + 3 compiler\ub294 y \ub610\ud55c Int\ub85c \uc720\ucd94\ud55c\ub2e4. \uc774\ubc88\uc5d0\ub294 \ubc18\ub300\ub85c compiler\uac00 types\ub85c \ubd80\ud130 values\ub97c \uc720\ucd94\ud558\ub294 \uacfc\uc815\uc744 \ubcfc \uac83\uc774\ub2e4. \uc65c \uc774\uac83\uc774 \uc720\uc6a9\ud558\ub0d0? \ud655\uc2e4\ud55c \ud558\ub098\ub294 compiler\uac00 value\ub97c \ucc3e\uc544\uc11c \uc904 \uc218 \uc788\uae30 \ub54c\ubb38\uc774\ub2e4. \uc774\ubc88 \ub808\uc2a8\uc758 \ub098\uba38\uc9c0\ub294 \uc774\ub7f0 \uba54\uce74\ub2c8\uc998\uc758 motivation\uc744 \uc18c\uac1c\ud558\uace0 \ub2e4\uc74c \ubc88 \ub808\uc2a8\uc740 how to use it\uc744 \uc124\uba85\ud560 \uac83\uc774\ub2e4.","title":"Week3-1: Type-Directed Programming"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#motivating-example","text":"parameter\ub85c List[Int]\ub97c \ubc1b\uc544\uc11c \uc815\ub82c\ud55c \uacb0\uacfc\ub97c List[Int]\ub85c \ub9ac\ud134\ud558\ub294 \ud568\uc218\ub97c \uc0dd\uac01\ud574\ubcf4\uc790. def sort(xs: List[Int]): List[Int] = { ... ... if (x < y) ... ... } \uc0c1\uc138 \ucf54\ub4dc\ub294 \uc5ec\uae30\uc5d0\uc11c \ud544\uc694\uac00 \uc5c6\uae30\uc5d0 \uc0dd\ub7b5\ud588\ub2e4. \uc704 \ucf54\ub4dc\ub294 Int\uc5d0 \ub300\ud574\uc11c\ub9cc \uc801\uc6a9 \uac00\ub2a5\ud558\ubbc0\ub85c general\ud558\uac8c \ubaa8\ub4e0 \ud0c0\uc785\uc5d0 \ub300\ud574\uc11c\ub3c4 \ub3d9\uc791\ud558\uac8c \ud558\uace0 \uc2f6\ub2e4. \uc774\uc5d0 \ub300\ud55c straightforward approach\ub294 polymorphic type\uc744 \uc0ac\uc6a9\ud558\ub294 \uac83\uc774\ub2e4. def sort[A](xs: List[A]): List[A] = ... \ud558\uc9c0\ub9cc \uc774\uac83\ub9cc\uc73c\ub85c\ub294 \ubd80\uc871\ud558\ub2e4. \uc65c\ub0d0\ud558\uba74 \uac01 type\ubcc4\ub85c compare\ub97c \ub2e4\ub974\uac8c \ud574\uc57c \ud558\uae30 \ub54c\ubb38\uc774\ub2e4. \uadf8\ub798\uc11c \uc774\ubc88\uc5d4 \uac01 compare \ud568\uc218\ub97c parameter\ub85c \ubc1b\ub3c4\ub85d \ud574\ubcf4\uc790. def sort[A](xs: List[A])(lessThan: (A, A) => Boolean): List[A] = { ... ... if (lessThan(x, y)) ... ... } \uadf8\ub807\uac8c \ub418\uba74 \uc544\ub798\uc640 \uac19\uc774 \uac00\ub2a5\ud558\ub2e4' val xs = List(-5, 6, 3, 2, 7) val strings = List(\"apple\", \"pear\", \"orange\", \"pineapple\") sort(xs)((x, y) => x < y) sort(strings)((s1, s2) => s1.compareTo(s2) < 0)","title":"Motivating Example"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#refactoring-with-ordering","text":"scala\ub294 standard library \uc5d0\uc11c comparing \ud558\ub294 \ud568\uc218\ub97c \uae30\ubcf8\uc73c\ub85c \uc81c\uacf5\ud55c\ub2e4. package scala.math trait Ordering[A] { def compare(a1: A, a2: A): Int def lt(a1: A, a2: A): Boolean = compare(a1, a2) <= 0 ... } compare \ud568\uc218\ub294 2\uac1c\uc758 parameter\ub97c \ubc1b\uc544\uc11c \uccab \ubc88\uc9f8 \uac12\uc774 \ud074 \uacbd\uc6b0 \uc591\uc218, \uc791\uc744 \uacbd\uc6b0 \uc74c\uc218, \ub3d9\uc77c\ud55c \uacbd\uc6b0 0\uc744 \ub9ac\ud134\ud55c\ub2e4. \uc774\ub97c \uc0ac\uc6a9\ud558\uba74 \uc544\ub798\uc640 \uac19\uc774 \ubcc0\uacbd \uac00\ub2a5\ud558\ub2e4. def sort[A](xs: List[A])(ord: Ordering[A]): List[A] = { ... ... if (ord.lt(x, y)) ... ... } import scala.math.Ordering sort(xs)(Ordering.Int) sort(strings)(Ordering.String) \uc5ec\uae30\uc5d0\uc11c \uc0ac\uc6a9 \uc911\uc778 Int\uc640 String\uc740 types \uc774 \uc544\ub2c8\uace0 values \uc784\uc744 \uc54c\uc544\uc57c \ud55c\ub2e4. scala\uc5d0\uc11c\ub294 types\uacfc values\uc5d0 \ub3d9\uc77c\ud55c symbol\uc744 \uc0ac\uc6a9\ud558\ub294 \uac83\uc774 \uac00\ub2a5\ud558\ub2e4. object Ordering { val Int = new Ordering[Int] { def compare(x: Int, y: Int) = if (x > y) 1 else if (x < y) -1 else 0 } }","title":"Refactoring With Ordering"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#reducing-boilerplate","text":"\uc9c0\uae08\uae4c\uc9c0 \uc815\uc758\ud55c \uac83\uc744 \ub530\ub974\uba74 \uc798 \ub3d9\uc791\ud55c\ub2e4. \ud558\uc9c0\ub9cc \ubaa8\ub4e0 \uacbd\uc6b0\uc5d0 \ub300\ud574 boilerplate\uac00 \uc874\uc7ac\ud558\uac8c \ub41c\ub2e4. Int\ub97c \ube44\uad50\ud560 \ub54c\ub9c8\ub2e4 Ordering.Int \ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \uc0ac\uc6a9\ud574\uc57c \ud55c\ub2e4. sort(xs)(Ordering.Int) sort(ys)(Ordering.Int) sort(strings)(Ordering.String)","title":"Reducing Boilerplate"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#implicit-parameters","text":"implicit \uc744 \uba85\uc2dc\ud568\uc73c\ub85c\uc11c compiler\uac00 argument ord \ub97c support\ub97c \ud558\uac8c \ud560 \uc218 \uc788\ub2e4. def sort[A](xs: List[A])(implicit ord: Ordering[A]): List[A] = ... sort(xs) sort(ys) sort(strings) \uc704\uc640 \uac19\uc774 \ud558\uba74 \ucef4\ud30c\uc77c\ub7ec\uac00 value\uc5d0 \ub9de\ucdb0 type\uc744 \uacb0\uc815\ud55c\ub2e4. \ucef4\ud30c\uc77c\ub7ec\uac00 \uc218\ud589\ud558\ub294 \uacfc\uc815\uc744 \uc790\uc138\ud788 \uc0b4\ud3b4\ubcf4\uc790. sort(xs) xs \uac00 List[Int] \ud0c0\uc785\uc774\ubbc0\ub85c \ucef4\ud30c\uc77c\ub7ec\ub294 \uc704\uc758 \ucf54\ub4dc\ub97c \uc544\ub798\uc640 \uac19\uc774 \ubcc0\ud658\ud55c\ub2e4. sort[Int](xs) \uadf8\ub9ac\uace0 \ucef4\ud30c\uc77c\ub7ec\ub294 candidate definition\uc911 Ordering[Int] \ud0c0\uc785\uc5d0 \ub9de\ub294 \uac83\uc744 \ucc3e\ub294\ub2e4. \uc704\uc758 \ucf00\uc774\uc2a4\uc5d0\uc11c\ub294 Ordering.Int\uc640 only matching\ub418\uace0 \ucef4\ud30c\uc77c\ub7ec\ub294 method sort\ub85c \uc774\ub97c \uc804\ub2ec\ud55c\ub2e4. sort[Int](xs)(Ordering.Int) candidate values\uac00 \uc5b4\ub5bb\uac8c \uc815\uc758\ub3c4\uc5b4\uc788\ub294 \uc9c0\ub97c \uc0b4\ud3b4 \ubcf4\uae30 \uc804\uc5d0 implicit \ud0a4\uc6cc\ub4dc\uc5d0 \ub300\ud574 \uc790\uc138\ud788 \uc54c\uc544\ubcf4\uc790. method\ub294 \uc624\uc9c1 \ud558\ub098\uc758 implicit parameter list\ub97c \uac00\uc9c8 \uc218 \uc788\uc73c\uba70 \uc774\ub294 \ub9c8\uc9c0\ub9c9 paramter\uac00 \ub418\uc57c \ud55c\ub2e4. At call site, the arguments of the given clause are usually left out, although it is possible to explicitly pass them: // Argument inferred by the compiler sort(xs) // Explicit argument sort(xs)(Ordering.Int.reverse)","title":"Implicit Parameters"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#candidates-for-implicit-parameters","text":"\ucef4\ud30c\uc77c\ub7ec\uac00 type T\uc5d0 \ub300\ud574 \uc5b4\ub5a4 candidate definition\ub97c \ucc3e\uc744\uae4c? \ucef4\ud30c\uc77c\ub7ec\ub294 \uc544\ub798 definition\uc744 \ucc3e\ub294\ub2e4. have type T, are marked implicit, are visible at the point of the function call, or are defined in a companion object associated with T. most specific\ud55c \uc815\uc758\ub97c \ucc3e\uac8c \ub418\uba74 \uadf8\uac83\uc744 \uc0ac\uc6a9\ud558\uace0 \uc5c6\ub2e4\uba74 error\ub97c report\ud55c\ub2e4.","title":"Candidates for Implicit Parameters"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#implicit-definition","text":"implicit definition\uc774\ub780 implicit \ud0a4\uc6cc\ub4dc\uc640 \ud568\uaed8 \uc815\uc758\ub41c \uac83\uc744 \ub9d0\ud55c\ub2e4. object Ordering { implicit val Int: Ordering[Int] = ... } \uc704\uc758 \ucf54\ub4dc\ub294 Int\ub77c\ub294 \uc774\ub984\uc744 \uac00\uc9c4 Ordering[Int] \ud0c0\uc785\uc758 implicit value\ub97c \uc815\uc758\ud55c \uac83\uc774\ub2e4. Any val, lazy val, def, or object definition can be marked implicit. \ub9c8\uc9c0\ub9c9\uc73c\ub85c implicit definitions\ub294 type parameters\uc640 implicit parameters\ub97c \uac00\uc9c8 \uc218 \uc788\ub2e4. implicit def orderingPair[A, B](implicit orderingA: Ordering[A], orderingB: Ordering[B] ): Ordering[(A, B)] = ...","title":"implicit Definition"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#implicit-search-scope","text":"type T\uc758 implicit value\ub97c \ucc3e\uae30 \uc704\ud574 \uccab \ubc88\uc9f8\ub85c visible(inherited, imported, or defined in an enclosing scope)\ud55c \ubaa8\ub4e0 implicit definitions\ub97c \ucc3e\ub294\ub2e4. \ub9cc\uc57d \ucef4\ud30c\uc77c\ub7ec\uac00 lexcial scope\uc5d0\uc11c implicit instance\uc640 \ub9e4\uce6d\ub418\ub294 type T\ub97c \ucc3e\uc9c0 \ubabb\ud558\uba74, T\uc640 \uad00\ub828\ub41c companion objects\uc5d0\uc11c \uc774\uc5b4\uc11c \ucc3e\ub294\ub2e4. (companion objects\uc640 types\ub294 other types\uc640 \uc5f0\uad00\uc788\ub2e4.) A companion object is an object that has the same name as a type. \uc608\ub85c object scala.math.Ordering is the companion of the type scala.math.Ordering. The types associated with a type T are: if T has parent types T\u2081 with T\u2082 ... with T\u2099, the union of the parts of T\u2081, ... T\u2099 as well as T itself, if T is a parameterized type S[T\u2081, T\u2082, ..., T\u2099], the union of the parts of S and T\u2081, ..., T\u2099, otherwise, just T itself. As an example, consider the following type hierarchy: trait Foo[A] trait Bar[A] extends Foo[A] trait Baz[A] extends Bar[A] trait X trait Y extends X \ub9cc\uc57d Bar[Y] \ud0c0\uc785\uc758 implicit value\uac00 \ud544\uc694\ud558\ub2e4\uba74 compiler\ub294 \uc544\ub798\uc640 \uac19\uc740 companion object\uc5d0\uc11c implicit definition\uc744 \ucc3e\uc744 \uac83\uc774\ub2e4. Bar, because it is a part of Bar[Y], Y, because it is a part of Bar[Y], Foo, because it is a parent type of Bar, and X, because it is a parent type of Y. However, the Baz companion object will not be visited.","title":"Implicit Search Scope"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#implicit-search-process","text":"search process\ub294 no candidate found \ud639\uc740 \ub9e4\uce6d\ub418\ub294 \ucd5c\uc18c\ud55c \ud558\ub098\uc758 candidate\ub97c \uacb0\uacfc\ub97c \ub9cc\ub4e4\uc5b4 \ub0b8\ub2e4. \ub9cc\uc57d no no available implicit definition matching \uc774\ub77c\uba74 \uc5d0\ub7ec\uac00 repot \ub41c\ub2e4. scala> def f(implicit n: Int) = () scala> f ^ error: could not find implicit value for parameter n: Int \ubc18\ub300\ub85c \ub458 \uc774\uc0c1\uc758 implicit definition\uc774 eligibale \ud558\ub2e4\uba74 ambiguity\uac00 report \ub41c\ub2e4. scala> implicit val x: Int = 0 scala> implicit val y: Int = 1 scala> def f(implicit n: Int) = () scala> f ^ error: ambiguous implicit values: both value x of type => Int same type\uc5d0 \ub9e4\uce6d\ub418\ub294 several implicit definitions\uac00 \uc788\uc5b4\ub3c4 \ud558\ub098\ub97c \ud2b9\uc815 \ud560 \uc218 \uc788\ub2e4\uba74 \uad1c\ucc2e\ub2e4. A definition a: A is more specific than a definition b: B if: type A has more \u201cfixed\u201d parts, or, a is defined in a class or object which is a subclass of the class defining b. Let\u2019s see a few examples of priorities at work. Which implicit definition matches the Int implicit parameter when the following method f is called? implicit def universal[A]: A = ??? implicit def int: Int = ??? def f(implicit n: Int) = () f \uc704\uc758 \uacbd\uc6b0\uc5d0\uc11c universal\uc740 type paramter\ub97c \uc9c0\ub2c8\uace0 int\ub294 \uc544\ub2c8\uae30\uc5d0, int\uac00 more fixed parts\ub97c \uac16\uace0 \uc774\ub294 universal\ubcf4\ub2e4 \uba3c\uc800 \uace0\ub824\ub41c\ub2e4. \uadf8\ub807\uae30 \ub54c\ubb38\uc5d0 \ucef4\ud30c\uc77c\ub7ec\uac00 int\ub97c \uc120\ud0dd\ud568\uc5d0 \uc788\uc5b4 ambiguity\uac00 \uc5c6\ub2e4. \uc544\ub798\uc640 \uac19\uc774 \uc788\uc744 \ub54c implicit Int \ud30c\ub77c\ubbf8\ud130\ub97c \uac16\ub294 f method\ub294 \uc5b4\ub290 implicit definition\uc5d0 \ub9e4\uce58 \ub420\uae4c? trait A { implicit val x: Int = 0 } trait B extends A { implicit val y: Int = 1 def f(implicit n: Int) = () f } y\uac00 A\ub97c extend\ud558\ub294 trait\uc774\ubbc0\ub85c y\uac00 A\ubcf4\ub2e4 more specific \ud558\ub2e4. \uadf8\ub7ec\ubbc0\ub85c \ucef4\ud30c\uc77c\ub7ec\uac00 y\ub97c \uc120\ud0dd\ud558\ub294 \uac83\uc5d0 ambiguity\ub294 \uc5c6\ub2e4.","title":"Implicit Search Process"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#context-bounds","text":"Syntactic sugar allows the omission of the implicit parameter list: def printSorted[A: Ordering](as: List[A]): Unit = { println(sort(as)) } Type parameter A has one context bound: Ordering. This is equivalent to writing: def printSorted[A](as: List[A])(implicit ev1: Ordering[A]): Unit = { println(sort(as)) } More generally, a method definition such as: def f[A: U\u2081 ... : U\u2099](ps): R = ... Is expanded to: def f[A](ps)(implicit ev\u2081: U\u2081[A], ..., ev\u2099: U\u2099[A]): R = ...","title":"Context Bounds"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#implicit-query","text":"At any point in a program, one can query an implicit value of a given type by calling the implicitly operation: scala> implicitly[Ordering[Int]] res0: Ordering[Int] = scala.math.Ordering$Int$@73564ab0 Note that implicitly is not a special keyword, it is defined as a library operation: def implicitly[A](implicit value: A): A = value","title":"Implicit Query"},{"location":"scala/Coursera/fpd-in-scala/week3_1-typedirectedprogramming/#summary","text":"In this lesson we have introduced the concept of type-directed programming, a language mechanism that infers values from types. There has to be a unique (most specific) implicit definition matching the queried type for it to be selected by the compiler. Implicit values are searched in the enclosing lexical scope (imports, parameters, inherited members) as well as in the implicit scope of the queried type. The implicit scope of type is made of implicit values defined in companion objects of types associated with the queried type.","title":"Summary"},{"location":"scala/Coursera/fpd-in-scala/week3_2-typeclasses/","text":"Week3-2: Type Classes In the previous lectures we have seen a particular pattern of code combining parameterized types and implicits. We have defined a parameterized type Ordering[A], implicit instances of that type for concrete types A, and implicit parameters of type Ordering[A]: trait Ordering[A] { def compare(a1: A, a2: A): Int } object Ordering { implicit val Int: Ordering[Int] = new Ordering[Int] { def compare(x: Int, y: Int) = if (x < y) -1 else if (x > y) 1 else 0 } implicit val String: Ordering[String] = new Ordering[String] { def compare(s: String, t: String) = s.compareTo(t) } } def sort[A: Ordering](xs: List[A]): List[A] = ... We say that Ordering is a type class. Type classes provide yet another form of polymorphism. The method sort can be called with lists containing elements of any type A for which there is an implicit value of type Ordering[A]. At compile-time, the compiler resolves the specific Ordering implementation that matches the type of the list elements. Retroactive Extension Type classes let us add new features to data types without changing the original definition of these data types. For instance, consider the following Rational type, modeling a rational number: /** A rational number * @param num Numerator * @param denom Denominator */ case class Rational(num: Int, denom: Int) We can add the capability \"to be compared\" to the type Rational by defining an implicit instance of type Ordering[Rational]: object RationalOrdering { implicit val orderingRational: Ordering[Rational] = new Ordering[Rational] { def compare(q: Rational, r: Rational): Int = q.num * r.denom - r.num * q.denom } } Laws So far, we have shown how to implement instances of a type class, for some specific types (Int, String, and Rational). Now, let\u2019s have a look at the other side: how to use (and reason about) type classes. For example, the sort function is written in terms of the Ordering type class, whose implementation is itself defined by each specific instance, and is therefore unknown at the time the sort function is written. If an Ordering instance implementation is incorrect, then the sort function becomes incorrect too! To prevent this from happening, type classes are often accompanied by laws, which describe properties that instances must satisfy, and that users of type classes can rely on. Can you think of properties that instances of the type class Ordering must satisfy, so that we can be confident that the method sort won\u2019t be broken? Instances of the Ordering[A] type class must satisfy the following properties: inverse: the sign of the result of comparing x and y must be the inverse of the sign of the result of comparing y and x, transitive: if a value x is lower than y and that y is lower than z, then x must also be lower than z, consistent: if two values x and y are equal, then the sign of the result of comparing x and z should be the same as the sign of the result of comparing y and z. The authors of a type class should think about such kind of laws and they should provide ways for instance implementers to check that these laws are satisfied. Example of Type Class: Ring Let\u2019s see how we can define a type class modeling a ring structure. A ring is an algebraic structure defined as follows according to Wikipedia: In mathematics, a ring is one of the fundamental algebraic structures used in abstract algebra. It consists of a set equipped with two binary operations that generalize the arithmetic operations of addition and multiplication. Through this generalization, theorems from arithmetic are extended to non-numerical objects such as polynomials, series, matrices and functions. This structure is so common that, by abstracting over the ring structure, developers could write programs that could then be applied to various domains (arithmetic, polynomials, series, matrices and functions). A ring is a set equipped with two binary operations, + and *, satisfying the following laws (called the ring axioms): (a + b) + c = a + (b + c) + is associative a + b = b + a + is commutative a + 0 = a 0 is the additive identity a + -a = 0 -a is the additive inverse of a (a * b) * c = a * (b * c) * is associative a * 1 = a 1 is the multiplicative identity a * (b + c) = a * b + a * c left distributivity (b + c) * a = b * a + c * a right distributivity Here is how we can define a ring type class in Scala: trait Ring[A] { def plus(x: A, y: A): A def mult(x: A, y: A): A def inverse(x: A): A def zero: A def one: A } Here is how we define an instance of Ring[Int]: object Ring { implicit val ringInt: Ring[Int] = new Ring[Int] { def plus(x: Int, y: Int): Int = x + y def mult(x: Int, y: Int): Int = x * y def inverse(x: Int): Int = -x def zero: Int = 0 def one: Int = 1 } } Finally, this is how we would define a function that checks that the + associativity law is satisfied by a given Ring instance: def plusAssociativity[A](x: A, y: A, z: A)(implicit ring: Ring[A]): Boolean = ring.plus(ring.plus(x, y), z) == ring.plus(x, ring.plus(y, z)) Note: in practice, the standard library already provides a type class Numeric, which models a ring structure. Summary In this lesson we have identified a new programming pattern: type classes. Type classes provide a form of polymorphism: they can be used to implement algorithms that can be applied to various types. The compiler selects the type class implementation for a specific type at compile-time. A type class definition is a trait that takes type parameters and defines operations that apply to these types. Generally, a type class definition is accompanied by laws, checking that implementations of their operations are correct.","title":"Week3-2: Type Classes"},{"location":"scala/Coursera/fpd-in-scala/week3_2-typeclasses/#week3-2-type-classes","text":"In the previous lectures we have seen a particular pattern of code combining parameterized types and implicits. We have defined a parameterized type Ordering[A], implicit instances of that type for concrete types A, and implicit parameters of type Ordering[A]: trait Ordering[A] { def compare(a1: A, a2: A): Int } object Ordering { implicit val Int: Ordering[Int] = new Ordering[Int] { def compare(x: Int, y: Int) = if (x < y) -1 else if (x > y) 1 else 0 } implicit val String: Ordering[String] = new Ordering[String] { def compare(s: String, t: String) = s.compareTo(t) } } def sort[A: Ordering](xs: List[A]): List[A] = ... We say that Ordering is a type class. Type classes provide yet another form of polymorphism. The method sort can be called with lists containing elements of any type A for which there is an implicit value of type Ordering[A]. At compile-time, the compiler resolves the specific Ordering implementation that matches the type of the list elements.","title":"Week3-2: Type Classes"},{"location":"scala/Coursera/fpd-in-scala/week3_2-typeclasses/#retroactive-extension","text":"Type classes let us add new features to data types without changing the original definition of these data types. For instance, consider the following Rational type, modeling a rational number: /** A rational number * @param num Numerator * @param denom Denominator */ case class Rational(num: Int, denom: Int) We can add the capability \"to be compared\" to the type Rational by defining an implicit instance of type Ordering[Rational]: object RationalOrdering { implicit val orderingRational: Ordering[Rational] = new Ordering[Rational] { def compare(q: Rational, r: Rational): Int = q.num * r.denom - r.num * q.denom } }","title":"Retroactive Extension"},{"location":"scala/Coursera/fpd-in-scala/week3_2-typeclasses/#laws","text":"So far, we have shown how to implement instances of a type class, for some specific types (Int, String, and Rational). Now, let\u2019s have a look at the other side: how to use (and reason about) type classes. For example, the sort function is written in terms of the Ordering type class, whose implementation is itself defined by each specific instance, and is therefore unknown at the time the sort function is written. If an Ordering instance implementation is incorrect, then the sort function becomes incorrect too! To prevent this from happening, type classes are often accompanied by laws, which describe properties that instances must satisfy, and that users of type classes can rely on. Can you think of properties that instances of the type class Ordering must satisfy, so that we can be confident that the method sort won\u2019t be broken? Instances of the Ordering[A] type class must satisfy the following properties: inverse: the sign of the result of comparing x and y must be the inverse of the sign of the result of comparing y and x, transitive: if a value x is lower than y and that y is lower than z, then x must also be lower than z, consistent: if two values x and y are equal, then the sign of the result of comparing x and z should be the same as the sign of the result of comparing y and z. The authors of a type class should think about such kind of laws and they should provide ways for instance implementers to check that these laws are satisfied.","title":"Laws"},{"location":"scala/Coursera/fpd-in-scala/week3_2-typeclasses/#example-of-type-class-ring","text":"Let\u2019s see how we can define a type class modeling a ring structure. A ring is an algebraic structure defined as follows according to Wikipedia: In mathematics, a ring is one of the fundamental algebraic structures used in abstract algebra. It consists of a set equipped with two binary operations that generalize the arithmetic operations of addition and multiplication. Through this generalization, theorems from arithmetic are extended to non-numerical objects such as polynomials, series, matrices and functions. This structure is so common that, by abstracting over the ring structure, developers could write programs that could then be applied to various domains (arithmetic, polynomials, series, matrices and functions). A ring is a set equipped with two binary operations, + and *, satisfying the following laws (called the ring axioms): (a + b) + c = a + (b + c) + is associative a + b = b + a + is commutative a + 0 = a 0 is the additive identity a + -a = 0 -a is the additive inverse of a (a * b) * c = a * (b * c) * is associative a * 1 = a 1 is the multiplicative identity a * (b + c) = a * b + a * c left distributivity (b + c) * a = b * a + c * a right distributivity Here is how we can define a ring type class in Scala: trait Ring[A] { def plus(x: A, y: A): A def mult(x: A, y: A): A def inverse(x: A): A def zero: A def one: A } Here is how we define an instance of Ring[Int]: object Ring { implicit val ringInt: Ring[Int] = new Ring[Int] { def plus(x: Int, y: Int): Int = x + y def mult(x: Int, y: Int): Int = x * y def inverse(x: Int): Int = -x def zero: Int = 0 def one: Int = 1 } } Finally, this is how we would define a function that checks that the + associativity law is satisfied by a given Ring instance: def plusAssociativity[A](x: A, y: A, z: A)(implicit ring: Ring[A]): Boolean = ring.plus(ring.plus(x, y), z) == ring.plus(x, ring.plus(y, z)) Note: in practice, the standard library already provides a type class Numeric, which models a ring structure.","title":"Example of Type Class: Ring"},{"location":"scala/Coursera/fpd-in-scala/week3_2-typeclasses/#summary","text":"In this lesson we have identified a new programming pattern: type classes. Type classes provide a form of polymorphism: they can be used to implement algorithms that can be applied to various types. The compiler selects the type class implementation for a specific type at compile-time. A type class definition is a trait that takes type parameters and defines operations that apply to these types. Generally, a type class definition is accompanied by laws, checking that implementations of their operations are correct.","title":"Summary"},{"location":"scala/Coursera/fpd-in-scala/week3_3-ConditionalImplicitDefinitions/","text":"Week3-3: Conditional Implicit Definitions In this lesson, we will see that implicit definitions can themselves take implicit parameters. Let\u2019s start with an example. Consider how we order two String values: is \"abc\" lexicographically before \"abd\"? To answer this question, we need to compare all the characters of the String values, element-wise: is a before a? No. is b before b? No. is c before d? Yes! We conclude that \"abc\" is before \"abd\". So, we compare two sequences of characters with an algorithm that compares the characters of the sequences element-wise. Said otherwise, we can define an ordering relation for sequence of characters based on the ordering relation for characters. Can we generalize this process to sequences of any element type A for which there is an implicit Ordering[A] instance? The signature of such an Ordering[List[A]] definition takes an implicit parameter of type Ordering[A]: implicit def orderingList[A](implicit ord: Ordering[A]): Ordering[List[A]] For reference, a complete implementation is shown below. You can see that at some point in the algorithm we call the operation compare of the ord parameter: implicit def orderingList[A](implicit ord: Ordering[A]): Ordering[List[A]] = new Ordering[List[A]] { def compare(xs: List[A], ys: List[A]) = (xs, ys) match { case (x :: xsTail, y :: ysTail) => val c = ord.compare(x, y) if (c != 0) c else compare(xsTail, ysTail) case (Nil, Nil) => 0 case (_, Nil) => 1 case (Nil, _) => -1 } } With this definition, we can sort a list of list of numbers, for example: scala> val xss = List(List(1, 2, 3), List(1), List(1, 1, 3)) res0: List[List[Int]] = List(List(1, 2, 3), List(1), List(1, 1, 3)) scala> sort(xss) res1: List[List[Int]] = List(List(1), List(1, 1, 3), List(1, 2, 3)) But let\u2019s take a step back. We haven\u2019t defined an instance of Ordering[List[Int]] and yet we have been able to sort a list of List[Int] elements! How did the compiler manage to provide such an instance to us? This happened in several steps. First, we called sort(xss). The compiler fixed the type parameter A of the method to List[Int], based on the type of the argument xss, as if we had written: sort[List[Int]](xss) Then, the compiler searched for an implicit definition of type Ordering[List[Int]]. It found that our orderingList definition could be a match under the condition that it could also find an implicit definition of type Ordering[Int], which it eventually found. Finally, the compiler inserted the following arguments for us: sort[List[Int]](xss)(orderingList(Ordering.Int)) In this case, the compiler combined two implicit definitions (orderingList and Ordering.Int) before terminating. In general, though, an arbitrary number of implicit definitions can be combined until the search hits a \u201cterminal\u201d definition. Consider for instance these four implicit definitions: implicit def a: A = ... implicit def aToB(implicit a: A): B = ... implicit def bToC(implicit b: B): C = ... implicit def cToD(implicit c: C): D = ... We can then ask the compiler to summon a value of type D: implicitly[D] The compiler finds that there is a candidate definition, cToD, that can provide such a D value, under the condition that it can also find an implicit definition of type C. Again, it finds that there is a candidate definition, bToC, that can provide such a C value, under the condition that it can also find an implicit definition of type B. Once again, it finds that there is candidate definition, aToB, that can provide such a B value, under the condition that it can also find an implicit value of type A. Finally, it finds a candidate definition for type A and the algorithm terminates! At the beginning of this lesson, we showed that by using implicit parameters the compiler could infer simple arguments for us. We have now reached a point where we can appreciate that the compiler can infer more complex arguments (by inferring arguments of arguments!). It not only significantly reduces code verbosity, it also alleviates developers from implementing parts of their programs, which are summoned by the compiler based on their type (hence the name \u201ctype-directed programming\u201d). In practice, complex fragments of programs such as serializers and deserializers of data types can be summoned by the compiler. Recursive Implicit Definitions What happens if we write an implicit definition that depends on itself? trait X implicit def loop(implicit x: X): X = x implicitly[X] The compiler detects that it keeps searching for an implicit definition of the same type and returns an error: error: diverging implicit expansion for type X starting with method loop Note: it is possible to write recursive implicit definitions by making sure that the search always terminates, but this is out of the scope of this lesson. Example: Sort by Multiple Criteria Consider a situation where we want to compare several movies. Each movie has a title, a rating (in number of \u201cstars\u201d), and a duration (in minutes): case class Movie(title: String, rating: Int, duration: Int) val movies = Seq( Movie(\"Interstellar\", 9, 169), Movie(\"Inglourious Basterds\", 8, 140), Movie(\"Fight Club\", 9, 139), Movie(\"Zodiac\", 8, 157) ) We want to sort movies by rating first, and then by duration. To achieve this, a first step is to change our sort function to take as parameter the sort criteria in addition to the elements to sort: def sort[A, B](elements: Seq[A])(critera: A => B)(implicit ord: Ordering[B] ): Seq[A] = ... The sort algorithm remains the same except that instead of comparing the elements together, we compare the criteria applied to each element. With this function, here is how we can sort movies by title: sort(movies)(_.title) And here is how we can sort them by rating: sort(movies)(_.rating) Each time the sort function is called, its ordering parameter is inferred by the compiler based on the type of the criteria (String and then Int, in the above examples). However, our initial problem was to sort the movies by multiple criteria. We would like to sort first by rating and then by duration: sort(movies)(movie => (movie.rating, movie.duration)) The type of the criteria is now a tuple type (Int, Int). Unfortunately, the compiler is unable to infer the corresponding ordering parameter. We need to define how simple orderings can be combined together to get an ordering for multiple criteria. We do so by defining the following implicit ordering: implicit def orderingPair[A, B](implicit orderingA: Ordering[A], orderingB: Ordering[B] ): Ordering[(A, B)] = ... This definition provides an ordering for pairs of type (A, B) given orderings for types A and B. The complete implementation is the following: implicit def orderingPair[A, B](implicit orderingA: Ordering[A], orderingB: Ordering[B] ): Ordering[(A, B)] = new Ordering[(A, B)] { def compare(pair1: (A, B), pair2: (A, B)): Int = { val firstCriteria = orderingA.compare(pair1._1, pair2._1) if (firstCriteria != 0) firstCriteria else orderingB.compare(pair1._2, pair2._2) } } We first compare the two values according to the first criteria, and if they are equal we compare them according to the second criteria. With this definition, the compiler is now able to infer the ordering for the following call: sort(movies)(movie => (movie.rating, movie.duration)) Here is the same call where the inferred parameter is explicitly written: sort(movies)(movie => (movie.rating, movie.duration))( orderingPair(Ordering.Int, Ordering.Int) ) Note that in the standard library the sort function that we have defined here is already available as a method sortBy on collections. Summary In this lesson, we have seen that: implicit definitions can also take implicit parameters, an arbitrary number of implicit definitions can be chained until a terminal definition is reached.","title":"Week3-3: Conditional Implicit Definitions"},{"location":"scala/Coursera/fpd-in-scala/week3_3-ConditionalImplicitDefinitions/#week3-3-conditional-implicit-definitions","text":"In this lesson, we will see that implicit definitions can themselves take implicit parameters. Let\u2019s start with an example. Consider how we order two String values: is \"abc\" lexicographically before \"abd\"? To answer this question, we need to compare all the characters of the String values, element-wise: is a before a? No. is b before b? No. is c before d? Yes! We conclude that \"abc\" is before \"abd\". So, we compare two sequences of characters with an algorithm that compares the characters of the sequences element-wise. Said otherwise, we can define an ordering relation for sequence of characters based on the ordering relation for characters. Can we generalize this process to sequences of any element type A for which there is an implicit Ordering[A] instance? The signature of such an Ordering[List[A]] definition takes an implicit parameter of type Ordering[A]: implicit def orderingList[A](implicit ord: Ordering[A]): Ordering[List[A]] For reference, a complete implementation is shown below. You can see that at some point in the algorithm we call the operation compare of the ord parameter: implicit def orderingList[A](implicit ord: Ordering[A]): Ordering[List[A]] = new Ordering[List[A]] { def compare(xs: List[A], ys: List[A]) = (xs, ys) match { case (x :: xsTail, y :: ysTail) => val c = ord.compare(x, y) if (c != 0) c else compare(xsTail, ysTail) case (Nil, Nil) => 0 case (_, Nil) => 1 case (Nil, _) => -1 } } With this definition, we can sort a list of list of numbers, for example: scala> val xss = List(List(1, 2, 3), List(1), List(1, 1, 3)) res0: List[List[Int]] = List(List(1, 2, 3), List(1), List(1, 1, 3)) scala> sort(xss) res1: List[List[Int]] = List(List(1), List(1, 1, 3), List(1, 2, 3)) But let\u2019s take a step back. We haven\u2019t defined an instance of Ordering[List[Int]] and yet we have been able to sort a list of List[Int] elements! How did the compiler manage to provide such an instance to us? This happened in several steps. First, we called sort(xss). The compiler fixed the type parameter A of the method to List[Int], based on the type of the argument xss, as if we had written: sort[List[Int]](xss) Then, the compiler searched for an implicit definition of type Ordering[List[Int]]. It found that our orderingList definition could be a match under the condition that it could also find an implicit definition of type Ordering[Int], which it eventually found. Finally, the compiler inserted the following arguments for us: sort[List[Int]](xss)(orderingList(Ordering.Int)) In this case, the compiler combined two implicit definitions (orderingList and Ordering.Int) before terminating. In general, though, an arbitrary number of implicit definitions can be combined until the search hits a \u201cterminal\u201d definition. Consider for instance these four implicit definitions: implicit def a: A = ... implicit def aToB(implicit a: A): B = ... implicit def bToC(implicit b: B): C = ... implicit def cToD(implicit c: C): D = ... We can then ask the compiler to summon a value of type D: implicitly[D] The compiler finds that there is a candidate definition, cToD, that can provide such a D value, under the condition that it can also find an implicit definition of type C. Again, it finds that there is a candidate definition, bToC, that can provide such a C value, under the condition that it can also find an implicit definition of type B. Once again, it finds that there is candidate definition, aToB, that can provide such a B value, under the condition that it can also find an implicit value of type A. Finally, it finds a candidate definition for type A and the algorithm terminates! At the beginning of this lesson, we showed that by using implicit parameters the compiler could infer simple arguments for us. We have now reached a point where we can appreciate that the compiler can infer more complex arguments (by inferring arguments of arguments!). It not only significantly reduces code verbosity, it also alleviates developers from implementing parts of their programs, which are summoned by the compiler based on their type (hence the name \u201ctype-directed programming\u201d). In practice, complex fragments of programs such as serializers and deserializers of data types can be summoned by the compiler.","title":"Week3-3: Conditional Implicit Definitions"},{"location":"scala/Coursera/fpd-in-scala/week3_3-ConditionalImplicitDefinitions/#recursive-implicit-definitions","text":"What happens if we write an implicit definition that depends on itself? trait X implicit def loop(implicit x: X): X = x implicitly[X] The compiler detects that it keeps searching for an implicit definition of the same type and returns an error: error: diverging implicit expansion for type X starting with method loop Note: it is possible to write recursive implicit definitions by making sure that the search always terminates, but this is out of the scope of this lesson.","title":"Recursive Implicit Definitions"},{"location":"scala/Coursera/fpd-in-scala/week3_3-ConditionalImplicitDefinitions/#example-sort-by-multiple-criteria","text":"Consider a situation where we want to compare several movies. Each movie has a title, a rating (in number of \u201cstars\u201d), and a duration (in minutes): case class Movie(title: String, rating: Int, duration: Int) val movies = Seq( Movie(\"Interstellar\", 9, 169), Movie(\"Inglourious Basterds\", 8, 140), Movie(\"Fight Club\", 9, 139), Movie(\"Zodiac\", 8, 157) ) We want to sort movies by rating first, and then by duration. To achieve this, a first step is to change our sort function to take as parameter the sort criteria in addition to the elements to sort: def sort[A, B](elements: Seq[A])(critera: A => B)(implicit ord: Ordering[B] ): Seq[A] = ... The sort algorithm remains the same except that instead of comparing the elements together, we compare the criteria applied to each element. With this function, here is how we can sort movies by title: sort(movies)(_.title) And here is how we can sort them by rating: sort(movies)(_.rating) Each time the sort function is called, its ordering parameter is inferred by the compiler based on the type of the criteria (String and then Int, in the above examples). However, our initial problem was to sort the movies by multiple criteria. We would like to sort first by rating and then by duration: sort(movies)(movie => (movie.rating, movie.duration)) The type of the criteria is now a tuple type (Int, Int). Unfortunately, the compiler is unable to infer the corresponding ordering parameter. We need to define how simple orderings can be combined together to get an ordering for multiple criteria. We do so by defining the following implicit ordering: implicit def orderingPair[A, B](implicit orderingA: Ordering[A], orderingB: Ordering[B] ): Ordering[(A, B)] = ... This definition provides an ordering for pairs of type (A, B) given orderings for types A and B. The complete implementation is the following: implicit def orderingPair[A, B](implicit orderingA: Ordering[A], orderingB: Ordering[B] ): Ordering[(A, B)] = new Ordering[(A, B)] { def compare(pair1: (A, B), pair2: (A, B)): Int = { val firstCriteria = orderingA.compare(pair1._1, pair2._1) if (firstCriteria != 0) firstCriteria else orderingB.compare(pair1._2, pair2._2) } } We first compare the two values according to the first criteria, and if they are equal we compare them according to the second criteria. With this definition, the compiler is now able to infer the ordering for the following call: sort(movies)(movie => (movie.rating, movie.duration)) Here is the same call where the inferred parameter is explicitly written: sort(movies)(movie => (movie.rating, movie.duration))( orderingPair(Ordering.Int, Ordering.Int) ) Note that in the standard library the sort function that we have defined here is already available as a method sortBy on collections.","title":"Example: Sort by Multiple Criteria"},{"location":"scala/Coursera/fpd-in-scala/week3_3-ConditionalImplicitDefinitions/#summary","text":"In this lesson, we have seen that: implicit definitions can also take implicit parameters, an arbitrary number of implicit definitions can be chained until a terminal definition is reached.","title":"Summary"}]}